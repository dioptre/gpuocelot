<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MC-GPU_v1.1.cu Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>MC-GPU_v1.1.cu</h1><a href="MC-GPU__v1_81_8cu.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment"></span>
<a name="l00002"></a>00002 <span class="comment">////////////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00003"></a>00003 <span class="comment"></span><span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">//               ****************************</span>
<a name="l00005"></a>00005 <span class="comment">//               *** MC-GPU , version 1.1 ***</span>
<a name="l00006"></a>00006 <span class="comment">//               ****************************</span>
<a name="l00007"></a>00007 <span class="comment">//</span><span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">/**</span>
<a name="l00009"></a>00009 <span class="comment"> *      \mainpage  MC-GPU v1.1</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> * \b MC-GPU is an x ray transport simulation code that can generate radiographic</span>
<a name="l00013"></a>00013 <span class="comment"> * projection images and computed tomography (CT) scans of voxelized objects,</span>
<a name="l00014"></a>00014 <span class="comment"> * including realistic human anatomy phantoms.</span>
<a name="l00015"></a>00015 <span class="comment"> * </span>
<a name="l00016"></a>00016 <span class="comment"> * The code implements a massively multi-threaded Monte Carlo simulation algorithm</span>
<a name="l00017"></a>00017 <span class="comment"> * for the transport of x rays in a voxelized geometry. The program has been</span>
<a name="l00018"></a>00018 <span class="comment"> * developed using the \b CUDA programming model and the simulation can be executed in</span>
<a name="l00019"></a>00019 <span class="comment"> * parallel in a state-of-the-art GPU from \b NVIDIA, giving an speed up of the order</span>
<a name="l00020"></a>00020 <span class="comment"> * of 15-25 times, compared to a CPU execution. The x ray interaction models and</span>
<a name="l00021"></a>00021 <span class="comment"> * cross sections have been adapted from \b PENELOPE \b 2006.</span>
<a name="l00022"></a>00022 <span class="comment"> * Currently, the code does not transport secondary electrons and the electrons</span>
<a name="l00023"></a>00023 <span class="comment"> * that would be created in photoelectric and Compton events are assumed to be</span>
<a name="l00024"></a>00024 <span class="comment"> * locally absorbed (dose is not reported).</span>
<a name="l00025"></a>00025 <span class="comment"> * </span>
<a name="l00026"></a>00026 <span class="comment"> * The MC-GPU code has been described in different scientific publications. A brief</span>
<a name="l00027"></a>00027 <span class="comment"> * description of the code features is given below. This description has been taken</span>
<a name="l00028"></a>00028 <span class="comment"> * from the main paper that can be cited to refer to this code:</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * \code</span>
<a name="l00031"></a>00031 <span class="comment"> *  Andreu Badal and Aldo Badano, "Accelerating Monte Carlo simulations of photon transport in a voxelized</span>
<a name="l00032"></a>00032 <span class="comment"> *  geometry using a massively parallel Graphics Processing Unit", Medical Physics 36, pp. 4878â€“4880 (2009)</span>
<a name="l00033"></a>00033 <span class="comment"> * \endcode</span>
<a name="l00034"></a>00034 <span class="comment"> *</span>
<a name="l00035"></a>00035 <span class="comment"> * This code is still in development, please report to the authors any issue/bug</span>
<a name="l00036"></a>00036 <span class="comment"> * that you may encounter. Feel free to suggest improvements to the code too. </span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> *</span>
<a name="l00039"></a>00039 <span class="comment"> *    \section  sec_disc  DISCLAIMER</span>
<a name="l00040"></a>00040 <span class="comment"> *</span>
<a name="l00041"></a>00041 <span class="comment"> *  This software and documentation (the "Software") were developed at the Food and</span>
<a name="l00042"></a>00042 <span class="comment"> *  Drug Administration (\b FDA) by employees of the Federal Government in the course</span>
<a name="l00043"></a>00043 <span class="comment"> *  of their official duties. Pursuant to Title 17, Section 105 of the United States</span>
<a name="l00044"></a>00044 <span class="comment"> *  Code, this work is not subject to copyright protection and is in the public</span>
<a name="l00045"></a>00045 <span class="comment"> *  domain. Permission is hereby granted, free of charge, to any person obtaining a</span>
<a name="l00046"></a>00046 <span class="comment"> *  copy of the Software, to deal in the Software without restriction, including</span>
<a name="l00047"></a>00047 <span class="comment"> *  without limitation the rights to use, copy, modify, merge, publish, distribute,</span>
<a name="l00048"></a>00048 <span class="comment"> *  sublicense, or sell copies of the Software or derivatives, and to permit persons</span>
<a name="l00049"></a>00049 <span class="comment"> *  to whom the Software is furnished to do so. FDA assumes no responsibility</span>
<a name="l00050"></a>00050 <span class="comment"> *  whatsoever for use by other parties of the Software, its source code,</span>
<a name="l00051"></a>00051 <span class="comment"> *  documentation or compiled executables, and makes no guarantees, expressed or</span>
<a name="l00052"></a>00052 <span class="comment"> *  implied, about its quality, reliability, or any other characteristic. Further,</span>
<a name="l00053"></a>00053 <span class="comment"> *  use of this code in no way implies endorsement by the FDA or confers any</span>
<a name="l00054"></a>00054 <span class="comment"> *  advantage in regulatory decisions.  Although this software can be redistributed</span>
<a name="l00055"></a>00055 <span class="comment"> *  and/or modified freely, we ask that any derivative works bear some notice that</span>
<a name="l00056"></a>00056 <span class="comment"> *  they are derived from it, and any modified versions bear some notice that they</span>
<a name="l00057"></a>00057 <span class="comment"> *  have been modified.</span>
<a name="l00058"></a>00058 <span class="comment"> * </span>
<a name="l00059"></a>00059 <span class="comment"> *     \section sec_Intro Code features</span>
<a name="l00060"></a>00060 <span class="comment"> *  </span>
<a name="l00061"></a>00061 <span class="comment"> * MC-GPU does not currently simulate the transport of electrons.</span>
<a name="l00062"></a>00062 <span class="comment"> * The interactions between the photons and the material objects are simulated</span>
<a name="l00063"></a>00063 <span class="comment"> * using the well-known interaction sampling models from the PENELOPE 2006</span>
<a name="l00064"></a>00064 <span class="comment"> * subroutine package.</span>
<a name="l00065"></a>00065 <span class="comment"> * </span>
<a name="l00066"></a>00066 <span class="comment"> * In order to speed up the ray-tracing of the code and minimize the access to the</span>
<a name="l00067"></a>00067 <span class="comment"> * slow GPU main memory, the photon trajectories across the voxels are computed</span>
<a name="l00068"></a>00068 <span class="comment"> * using the Woodcock tracking algorithm.</span>
<a name="l00069"></a>00069 <span class="comment"> * With this technique the photons perceive the geometry as a uniform medium</span>
<a name="l00070"></a>00070 <span class="comment"> * composed of the material of the most attenuating voxel.</span>
<a name="l00071"></a>00071 <span class="comment"> * In this way, the voxel boundaries do not have to be explicitly calculated and</span>
<a name="l00072"></a>00072 <span class="comment"> * multiple voxels can be crossed in a single step.</span>
<a name="l00073"></a>00073 <span class="comment"> * To keep the simulation unbiased, some of the interactions are considered</span>
<a name="l00074"></a>00074 <span class="comment"> * "virtual" (i.e., do not change the photon energy or direction of movement),</span>
<a name="l00075"></a>00075 <span class="comment"> * depending on the actual energy and the material at the interaction site.</span>
<a name="l00076"></a>00076 <span class="comment"> * In a typical simulation, several thousand threads are launched simultaneously in</span>
<a name="l00077"></a>00077 <span class="comment"> * the GPU, each one of them simulating a batch of 10000, or more, photon tracks.</span>
<a name="l00078"></a>00078 <span class="comment"> * </span>
<a name="l00079"></a>00079 <span class="comment"> * The random number generator used in PENELOPE, ranecu, is also used in the GPU</span>
<a name="l00080"></a>00080 <span class="comment"> * program.</span>
<a name="l00081"></a>00081 <span class="comment"> * To ensure that the simulated tracks are not correlated, each thread initializes</span>
<a name="l00082"></a>00082 <span class="comment"> * the generator to a unique position in the random sequence, far enough from the</span>
<a name="l00083"></a>00083 <span class="comment"> * other threads, using the algorithm implemented in the seedsMLCG code.</span>
<a name="l00084"></a>00084 <span class="comment"> * </span>
<a name="l00085"></a>00085 <span class="comment"> * The new code is currently used in the study of scatter in x-ray imaging and</span>
<a name="l00086"></a>00086 <span class="comment"> * includes a tally to generate radiographic images.</span>
<a name="l00087"></a>00087 <span class="comment"> * The image is formed by counting the energy that enters a user-defined 2D grid of</span>
<a name="l00088"></a>00088 <span class="comment"> * pixels, which is a simple approximation to a noise-free flat-panel detector with</span>
<a name="l00089"></a>00089 <span class="comment"> * 100% detection efficiency; the pixel values have units of eV/cm^2.</span>
<a name="l00090"></a>00090 <span class="comment"> * Four different images are reported at the end of the simulation, corresponding</span>
<a name="l00091"></a>00091 <span class="comment"> * to the signal produced by non-scattered, single Compton, single Rayleigh, and</span>
<a name="l00092"></a>00092 <span class="comment"> * multi-scattered photons.</span>
<a name="l00093"></a>00093 <span class="comment"> * The radiation source is implemented as a point source emitting monoenergetic</span>
<a name="l00094"></a>00094 <span class="comment"> * photons within a fan beam, producing a rectangular field on the detector</span>
<a name="l00095"></a>00095 <span class="comment"> * equivalent to a collimated cone beam.</span>
<a name="l00096"></a>00096 <span class="comment"> * </span>
<a name="l00097"></a>00097 <span class="comment"> * </span>
<a name="l00098"></a>00098 <span class="comment"> *    \section sec_CPU Code compilation and execution</span>
<a name="l00099"></a>00099 <span class="comment"> *</span>
<a name="l00100"></a>00100 <span class="comment"> *   MC-GPU has been tested only in the Linux operating system.</span>
<a name="l00101"></a>00101 <span class="comment"> *   A Makefile script is provided to compile the MC-GPU code in Linux.</span>
<a name="l00102"></a>00102 <span class="comment"> *   The CUDA libraries and the GNU GCC compiler must be previously installed.</span>
<a name="l00103"></a>00103 <span class="comment"> *   The Makefile may have to be edited to modify the library path.</span>
<a name="l00104"></a>00104 <span class="comment"> *</span>
<a name="l00105"></a>00105 <span class="comment"> *   A README text file is provided with the MC-GPU source code. Read this file for</span>
<a name="l00106"></a>00106 <span class="comment"> *   more information on the code usage. An example simulation input file is also</span>
<a name="l00107"></a>00107 <span class="comment"> *   provided.</span>
<a name="l00108"></a>00108 <span class="comment"> *</span>
<a name="l00109"></a>00109 <span class="comment"> *   MC-GPU uses CUDA to access the GPU but all the actual computations are coded</span>
<a name="l00110"></a>00110 <span class="comment"> *   in standard C code.</span>
<a name="l00111"></a>00111 <span class="comment"> *   All the CUDA specific commands are enclosed within preprocessor if statements.</span>
<a name="l00112"></a>00112 <span class="comment"> *   Defining the pre-processor variable "USING_CUDA" (i.e., compiling with</span>
<a name="l00113"></a>00113 <span class="comment"> *   "-DUSING_CUDA") the particle transport is executed in parallel in an</span>
<a name="l00114"></a>00114 <span class="comment"> *   NVIDIA GPU using CUDA. Otherwise, the code is sequentially executed in</span>
<a name="l00115"></a>00115 <span class="comment"> *   the CPU.</span>
<a name="l00116"></a>00116 <span class="comment"> * </span>
<a name="l00117"></a>00117 <span class="comment"> * </span>
<a name="l00118"></a>00118 <span class="comment"> *    \section sec_CT Parallel simulation of CT scans:</span>
<a name="l00119"></a>00119 <span class="comment"> * </span>
<a name="l00120"></a>00120 <span class="comment"> *   From version 1.1, MC-GPU allows the simulation of a CT scan. The CT is</span>
<a name="l00121"></a>00121 <span class="comment"> *   simulated generating multiple projection images around the static voxelized</span>
<a name="l00122"></a>00122 <span class="comment"> *   geometry. To speed up the CT simulation, the MPI library is used to address</span>
<a name="l00123"></a>00123 <span class="comment"> *   multiple GPUs and obtain multiple projections in parallel. In order to</span>
<a name="l00124"></a>00124 <span class="comment"> *   activate the MPI code, the pre-processor variable "USING_MPI" has to be</span>
<a name="l00125"></a>00125 <span class="comment"> *   defined (ie, compiling with "-DUSING_MPI").</span>
<a name="l00126"></a>00126 <span class="comment"> *   To use the code in parallel in N GPUs (in a single computer), the user</span>
<a name="l00127"></a>00127 <span class="comment"> *   has to run the program with N MPI threads in the CPU (eg,</span>
<a name="l00128"></a>00128 <span class="comment"> *   "mpirun -np 4 ./MC-GPU.x MC-GPU.in"). Each thread will get a unique id in</span>
<a name="l00129"></a>00129 <span class="comment"> *   the CPU (myID=0-&gt;N) and will address a unique GPU. The CT simulation will</span>
<a name="l00130"></a>00130 <span class="comment"> *   then be split so that the threads simulate consecutive projections</span>
<a name="l00131"></a>00131 <span class="comment"> *   independently, avoiding any intercommunication between threads.</span>
<a name="l00132"></a>00132 <span class="comment"> * </span>
<a name="l00133"></a>00133 <span class="comment"> * </span>
<a name="l00134"></a>00134 <span class="comment"> * </span>
<a name="l00135"></a>00135 <span class="comment"> * </span>
<a name="l00136"></a>00136 <span class="comment"> * </span>
<a name="l00137"></a>00137 <span class="comment"> *                      @file    MC-GPU_v1.1.cu</span>
<a name="l00138"></a>00138 <span class="comment"> *                      @author  Andreu Badal (Andreu.Badal-Soler@fda.hhs.gov)</span>
<a name="l00139"></a>00139 <span class="comment"> *                      @date    2010/05/14</span>
<a name="l00140"></a>00140 <span class="comment"> *                        -- First version:  2009/03/17</span>
<a name="l00141"></a>00141 <span class="comment"> */</span> <span class="comment"></span>
<a name="l00142"></a>00142 <span class="comment">////////////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00143"></a>00143 <span class="comment"></span>
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="comment">// *** Include header file with the structures and functions declarations</span>
<a name="l00151"></a>00151 <span class="preprocessor">#include &lt;<a class="code" href="MC-GPU__v1_81_8h.html" title="Header file containing the declarations for the MC-GPU code.">MC-GPU_v1.1.h</a>&gt;</span>
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="comment">// *** Include the computing kernel:</span>
<a name="l00154"></a>00154 <span class="preprocessor">#include &lt;<a class="code" href="MC-GPU__kernel__v1_81_8cu.html" title="Definition of the CUDA GPU kernel for the simulation of x ray tracks in a voxelized...">MC-GPU_kernel_v1.1.cu</a>&gt;</span>
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="comment"></span>
<a name="l00157"></a>00157 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00158"></a>00158 <span class="comment">//!  Main program to transport x rays in a 3D voxel geometry using the GPU.</span>
<a name="l00159"></a>00159 <span class="comment">//!  This function reads the description of the simulation from an external file</span>
<a name="l00160"></a>00160 <span class="comment">//!  given in the command line. This input file defines the number of particles to</span>
<a name="l00161"></a>00161 <span class="comment">//!  simulate, the characteristics of the x-ray source and the detector, the number</span>
<a name="l00162"></a>00162 <span class="comment">//!  and spacing of the projections (if simulating a CT), the location of the</span>
<a name="l00163"></a>00163 <span class="comment">//!  material files containing the interaction mean free paths, and the location</span>
<a name="l00164"></a>00164 <span class="comment">//!  of the voxelized geometry file.</span>
<a name="l00165"></a>00165 <span class="comment">//!</span>
<a name="l00166"></a>00166 <span class="comment">//!                            @author  Andreu Badal</span>
<a name="l00167"></a>00167 <span class="comment">//!                            @date    2010/03/19</span>
<a name="l00168"></a>00168 <span class="comment">//!</span>
<a name="l00169"></a>00169 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00170"></a><a class="code" href="MC-GPU__v1_81_8cu.html#3c04138a5bfe5d72780bb7e82a18e627">00170</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="MC-GPU__v1_81_8cu.html#3c04138a5bfe5d72780bb7e82a18e627" title="Main program to transport x rays in a 3D voxel geometry using the GPU.">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
<a name="l00171"></a>00171 {
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 <span class="preprocessor">#ifdef USING_MPI</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span><span class="comment">// -- Using MPI to address multiple GPUs in the same workstation (use only to simulate a CT scan).</span>
<a name="l00175"></a>00175   <span class="keywordtype">int</span> myID = -88, numprocs = -99;
<a name="l00176"></a>00176   MPI_Init(&amp;argc, &amp;argv);                   <span class="comment">// Init MPI and get the current thread ID </span>
<a name="l00177"></a>00177   MPI_Comm_rank(MPI_COMM_WORLD, &amp;myID);
<a name="l00178"></a>00178   MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);
<a name="l00179"></a>00179   printf(<span class="stringliteral">"            *** MPI run:  myId=%d , numprocs=%d\n"</span>,myID,numprocs);
<a name="l00180"></a>00180   fflush(stdout);   <span class="comment">// Clear the screen output buffer</span>
<a name="l00181"></a>00181   MPI_Barrier(MPI_COMM_WORLD);   <span class="comment">// Synchronize MPI threads  </span>
<a name="l00182"></a>00182 <span class="preprocessor">#else</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span>  <span class="keywordtype">int</span> myID = 0, numprocs = 1;   <span class="comment">// Only one CPU thread used when MPI is not activated (multiple projections will be simulated sequentially).</span>
<a name="l00184"></a>00184 <span class="preprocessor">#endif</span>
<a name="l00185"></a>00185 <span class="preprocessor"></span>  
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <span class="comment">// *** Declare the arrays and structures that will contain the simulation data:</span>
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <span class="keyword">struct </span><a class="code" href="structvoxel__struct.html" title="Structure defining a voxelized box with the back-lower corner at the coordinate origin...">voxel_struct</a> voxel_data;          <span class="comment">// Define the geometric constants of the voxel file</span>
<a name="l00190"></a>00190   <span class="keyword">struct </span><a class="code" href="structsource__struct.html" title="Structure storing the data defining the source model.">source_struct</a> source_data;        <span class="comment">// Define the particles source</span>
<a name="l00191"></a>00191   <span class="keyword">struct </span><a class="code" href="structdetector__struct.html" title="Structure storing the data defining the x-ray detector.">detector_struct</a> detector_data;    <span class="comment">// Define an x ray detector</span>
<a name="l00192"></a>00192   <span class="keyword">struct </span><a class="code" href="structlinear__interp.html" title="Structure with the basic data required by the linear interpolation of the mean free...">linear_interp</a> mfp_table_data;     <span class="comment">// Constant data for the linear interpolation</span>
<a name="l00193"></a>00193 
<a name="l00194"></a>00194   <span class="keyword">struct </span><a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a>  compton_table;    <span class="comment">// Structure containing Compton sampling data (to be copied to CONSTANT memory)</span>
<a name="l00195"></a>00195   <span class="keyword">struct </span><a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a> rayleigh_table;   <span class="comment">// Structure containing Rayleigh sampling data (to be copied to CONSTANT memory)</span>
<a name="l00196"></a>00196   
<a name="l00197"></a>00197   float2 *voxel_mat_dens = NULL;           <span class="comment">// Poiter where voxels array will be allocated</span>
<a name="l00198"></a>00198   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> voxel_mat_dens_bytes = 0;   <span class="comment">// Size (in bytes) of the voxels array (using unsigned int to allocate up to 4.2GBytes)</span>
<a name="l00199"></a>00199   <span class="keywordtype">float</span> density_max[<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>];
<a name="l00200"></a>00200   <span class="keywordtype">float</span> density_nominal[<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>];
<a name="l00201"></a>00201   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> *image = NULL;    <span class="comment">// Poiter where image array will be allocated</span>
<a name="l00202"></a>00202   <span class="keywordtype">int</span> image_bytes = -1;                    <span class="comment">// Size of the image array</span>
<a name="l00203"></a>00203   <span class="keywordtype">int</span> mfp_table_bytes = -1, mfp_Woodcock_table_bytes = -1;   <span class="comment">// Size of the table arrays</span>
<a name="l00204"></a>00204   float2 *mfp_Woodcock_table = NULL;                <span class="comment">// Linear interpolation data for the Woodcock mean free path [cm]</span>
<a name="l00205"></a>00205   float3 *mfp_table_a = NULL, *mfp_table_b = NULL;  <span class="comment">// Linear interpolation data for 3 different interactions:</span>
<a name="l00206"></a>00206                                               <span class="comment">//  (1) inverse total mean free path (divided by density, cm^2/g)</span>
<a name="l00207"></a>00207                                               <span class="comment">//  (2) inverse Compton mean free path (divided by density, cm^2/g)</span>
<a name="l00208"></a>00208                                               <span class="comment">//  (3) inverse Rayleigh mean free path (divided by density, cm^2/g)</span>
<a name="l00209"></a>00209   
<a name="l00210"></a>00210 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span>  <span class="comment">// - MASTER_THREAD == "if(0==myID)": macro to print the messages just once when using MPI threads; it has no effect if MPI is not used.</span>
<a name="l00212"></a>00212   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf  (<span class="stringliteral">"\n             *** CUDA SIMULATION IN THE GPU ***\n"</span>);
<a name="l00213"></a>00213 <span class="preprocessor">#else</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span>  <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf  (<span class="stringliteral">"\n             *** SIMULATION IN THE CPU ***\n"</span>);
<a name="l00215"></a>00215 <span class="preprocessor">#endif</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span>
<a name="l00217"></a>00217   time_t current_time = time(NULL);     <span class="comment">// Get current time (in seconds)</span>
<a name="l00218"></a>00218   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n****** Code execution started on: %s\n"</span>, ctime(&amp;current_time));
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"    -- INITIALIZATION phase:\n"</span>);
<a name="l00221"></a>00221 
<a name="l00222"></a>00222   <span class="comment">// -- Start time counter:</span>
<a name="l00223"></a>00223   clock_t clock_start, clock_end;      <span class="comment">// (requires standard header &lt;time.h&gt;)</span>
<a name="l00224"></a>00224   clock_start = clock();               <span class="comment">// Get current clock counter</span>
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 
<a name="l00227"></a>00227   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> total_histories;
<a name="l00228"></a>00228   <span class="keywordtype">int</span> histories_per_thread, seed_input, num_threads_per_block, gpu_id, num_projections;
<a name="l00229"></a>00229   <span class="keywordtype">double</span> D_angle, angularROI_0, angularROI_1, initial_angle;
<a name="l00230"></a>00230   <span class="keywordtype">char</span> file_name_voxels[250], file_name_materials[<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>][250], file_name_output[250];  
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   <span class="comment">// *** Read the input file given in the command line and return the significant data:</span>
<a name="l00233"></a>00233   <a class="code" href="MC-GPU__v1_81_8cu.html#5cd97f26e0582ba1236d387bd8b9d2e5" title="Read the input file given in the command line and return the significant data.">read_input</a>(argc, argv, myID, &amp;total_histories, &amp;seed_input, &amp;gpu_id, &amp;num_threads_per_block, &amp;histories_per_thread, &amp;detector_data, &amp;image, &amp;image_bytes, &amp;source_data, file_name_voxels, file_name_materials, file_name_output, &amp;num_projections, &amp;D_angle, &amp;angularROI_0, &amp;angularROI_1, &amp;initial_angle);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235         float3 detector_center;
<a name="l00236"></a>00236         detector_center.x = source_data.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].x + source_data.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x * detector_data.<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>;   <span class="comment">// Set the center of the detector straight ahead of the focal spot.</span>
<a name="l00237"></a>00237         detector_center.y = source_data.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].y + source_data.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y * detector_data.<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>;
<a name="l00238"></a>00238         detector_center.z = source_data.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].z + source_data.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z * detector_data.<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a>
<a name="l00241"></a>00241   {
<a name="l00242"></a>00242         printf(<span class="stringliteral">"                       total_histories = %lld\n"</span>, total_histories);
<a name="l00243"></a>00243         printf(<span class="stringliteral">"                           random seed = %d\n"</span>, seed_input);
<a name="l00244"></a>00244         printf(<span class="stringliteral">"                         source energy = %.3f keV\n"</span>, (source_data.<a class="code" href="structsource__struct.html#9e48c14733a7848fa9e038088c18847a">energy</a>/1.0e3f));
<a name="l00245"></a>00245         
<a name="l00246"></a>00246 <span class="comment">//         printf("            azimuthal, polar apertures = %.6f , %.6f degrees\n", 2.0*atan(source_data.tan_phi_semiaperture)*RAD2DEG, 2.0*atan(source_data.tan_theta_semiaperture)*RAD2DEG);</span>
<a name="l00247"></a>00247         printf(<span class="stringliteral">"      azimuthal (phi), polar apertures = %.6f , %.6f degrees\n"</span>, source_data.<a class="code" href="structsource__struct.html#01b06b35c2bc440ad0091dddde0cad06">D_phi</a>*RAD2DEG, 2.0*(90.0 - acos(source_data.<a class="code" href="structsource__struct.html#d3b7a93633ec87d036453e54e7e7abad">cos_theta_low</a>)*RAD2DEG) );
<a name="l00248"></a>00248 
<a name="l00249"></a>00249          
<a name="l00250"></a>00250         printf(<span class="stringliteral">"                   focal spot position = (%f, %f, %f)\n"</span>, source_data.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].x, source_data.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].y, source_data.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].z);
<a name="l00251"></a>00251         printf(<span class="stringliteral">"                      source direction = (%f, %f, %f)\n"</span>, source_data.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x, source_data.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y, source_data.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z);
<a name="l00252"></a>00252         printf(<span class="stringliteral">"                  initial angle from X = %lf\n"</span>, initial_angle*RAD2DEG);
<a name="l00253"></a>00253         printf(<span class="stringliteral">"                       detector center = (%f, %f, %f)\n"</span>, detector_center.x, detector_center.y, detector_center.z);
<a name="l00254"></a>00254         printf(<span class="stringliteral">"           detector low corner (at +Y) = (%f, %f, %f)\n"</span>, detector_data.<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].x, detector_data.<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].y, detector_data.<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].z);
<a name="l00255"></a>00255         printf(<span class="stringliteral">"              source-detector distance = %f cm\n"</span>, detector_data.<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>);
<a name="l00256"></a>00256         printf(<span class="stringliteral">"                number of pixels image = %dx%d\n"</span>, detector_data.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x, detector_data.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y);
<a name="l00257"></a>00257         printf(<span class="stringliteral">"                            pixel size = %.3fx%.3f cm\n"</span>, 1.0f/detector_data.<a class="code" href="structdetector__struct.html#3c6f9e59e89db06211ccea63287e2826">inv_pixel_size_X</a>, 1.0f/detector_data.<a class="code" href="structdetector__struct.html#a91fc94f674ad7af8eca577f4d8cd22b">inv_pixel_size_Z</a>);
<a name="l00258"></a>00258         printf(<span class="stringliteral">"                 number of projections = %d\n"</span>, num_projections);
<a name="l00259"></a>00259         <span class="keywordflow">if</span> (num_projections!=1)
<a name="l00260"></a>00260         {
<a name="l00261"></a>00261           printf(<span class="stringliteral">"             angle between projections = %lf\n"</span>, D_angle*RAD2DEG);
<a name="l00262"></a>00262           printf(<span class="stringliteral">"            angular region of interest = [%lf,%lf] degrees\n"</span>, angularROI_0*RAD2DEG, angularROI_1*RAD2DEG);
<a name="l00263"></a>00263         }
<a name="l00264"></a>00264         printf(<span class="stringliteral">"                      Input voxel file = %s\n"</span>, file_name_voxels);
<a name="l00265"></a>00265         printf(<span class="stringliteral">"                     Output image file = %s\n"</span>, file_name_output);
<a name="l00266"></a>00266 }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 
<a name="l00269"></a>00269   <span class="comment">// *** Set the detectors and sources for the CT trajectory (if needed, ie, for more than one projection):</span>
<a name="l00270"></a>00270   <span class="keywordflow">if</span> (num_projections != 1)
<a name="l00271"></a>00271     <a class="code" href="MC-GPU__v1_81_8cu.html#db95164a1253ee2aafeab8a5e0a8e7e3" title="Sets the CT trajectory: store in memory the source and detector rotations that are...">set_CT_trajectory</a>(myID, num_projections, D_angle, angularROI_0, angularROI_1, &amp;source_data, &amp;detector_data);
<a name="l00272"></a>00272 
<a name="l00273"></a>00273   fflush(stdout);
<a name="l00274"></a>00274         
<a name="l00275"></a>00275 
<a name="l00276"></a>00276   <span class="comment">// *** Read the voxel data and allocate the density map matrix. Return the maximum density:</span>
<a name="l00277"></a>00277   <a class="code" href="MC-GPU__v1_81_8cu.html#1daa1f1df034e2ed743ee7012e427222" title="Read the voxel data and allocate the material and density matrix.">load_voxels</a>(myID, file_name_voxels, density_max, &amp;voxel_data, &amp;voxel_mat_dens, &amp;voxel_mat_dens_bytes);  
<a name="l00278"></a>00278     <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       Total CPU memory allocated for voxels vector and data structures = %f Mbytes\n"</span>, (voxel_mat_dens_bytes+image_bytes+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structvoxel__struct.html" title="Structure defining a voxelized box with the back-lower corner at the coordinate origin...">voxel_struct</a>)+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structsource__struct.html" title="Structure storing the data defining the source model.">source_struct</a>)+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structdetector__struct.html" title="Structure storing the data defining the x-ray detector.">detector_struct</a>)+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structlinear__interp.html" title="Structure with the basic data required by the linear interpolation of the mean free...">linear_interp</a>)+2*mfp_table_bytes+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a>)+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a>))/(1024.f*1024.f));
<a name="l00279"></a>00279 
<a name="l00280"></a>00280   <span class="comment">// *** Read the material mean free paths and set the interaction table in a "linear_interp" structure:</span>
<a name="l00281"></a>00281   <a class="code" href="MC-GPU__v1_81_8cu.html#55f3171a6cdb59fc43e65aa19c676d80" title="Read the material input files and set the mean free paths and the &amp;quot;linear_interp&amp;quot;...">load_material</a>(myID, file_name_materials, density_max, density_nominal, &amp;mfp_table_data, &amp;mfp_Woodcock_table, &amp;mfp_Woodcock_table_bytes, &amp;mfp_table_a, &amp;mfp_table_b, &amp;mfp_table_bytes, &amp;rayleigh_table, &amp;compton_table);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="comment">// -- Check that the input material tables and the x-ray source are consistent:</span>
<a name="l00284"></a>00284     <span class="keywordflow">if</span> ( (source_data.<a class="code" href="structsource__struct.html#9e48c14733a7848fa9e038088c18847a">energy</a> &lt; mfp_table_data.<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a>) || (source_data.<a class="code" href="structsource__struct.html#9e48c14733a7848fa9e038088c18847a">energy</a> &gt; (mfp_table_data.<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a> + (mfp_table_data.<a class="code" href="structlinear__interp.html#2bea2f84374be1b9afd5d896b16a7a46">num_values</a>-1)/mfp_table_data.<a class="code" href="structlinear__interp.html#4b743ecf01ca7d075cc6b36b9ce2f0a1">ide</a>)) )
<a name="l00285"></a>00285     {
<a name="l00286"></a>00286       <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n !!ERROR!! The input x-ray source energy (%f eV) is outside the tabulated energy interval (from %f to %f eV)!!\n\n"</span>, source_data.<a class="code" href="structsource__struct.html#9e48c14733a7848fa9e038088c18847a">energy</a>, mfp_table_data.<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a>, (mfp_table_data.<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a>+(mfp_table_data.<a class="code" href="structlinear__interp.html#2bea2f84374be1b9afd5d896b16a7a46">num_values</a>-1)/mfp_table_data.<a class="code" href="structlinear__interp.html#4b743ecf01ca7d075cc6b36b9ce2f0a1">ide</a>));
<a name="l00287"></a>00287       exit(-1);
<a name="l00288"></a>00288     }
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="preprocessor">#ifdef USING_MPI</span>
<a name="l00292"></a>00292 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (myID != gpu_id)
<a name="l00293"></a>00293     gpu_id = myID;     <span class="comment">// Use the GPU with the same number as the CPU thread number (from '0' to 'numprocs-1')</span>
<a name="l00294"></a>00294   <span class="keywordflow">else</span>                 <span class="comment">// but skip the GPU number given in the input file (useful if GPU 0 is attached to a display).</span>
<a name="l00295"></a>00295     gpu_id = numprocs;
<a name="l00296"></a>00296 <span class="preprocessor">#endif</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span>
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span>  <span class="comment">// -- Declare the pointers to the device global memory, when using the GPU:</span>
<a name="l00301"></a>00301   float2 *voxel_mat_dens_device     = NULL,
<a name="l00302"></a>00302          *mfp_Woodcock_table_device = NULL;
<a name="l00303"></a>00303   float3 *mfp_table_a_device        = NULL,
<a name="l00304"></a>00304          *mfp_table_b_device        = NULL;
<a name="l00305"></a>00305   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> *image_device          = NULL;
<a name="l00306"></a>00306   <span class="keyword">struct </span><a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a> *rayleigh_table_device = NULL;
<a name="l00307"></a>00307   <span class="keyword">struct </span><a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a>  *compton_table_device  = NULL;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309   <span class="comment">// -- Sets the CUDA enabled GPU that will be used in the simulation, and allocate and copies the simulation data in the GPU global and constant memories.</span>
<a name="l00310"></a>00310   init_CUDA_device(&amp;gpu_id, myID, &amp;voxel_data, &amp;source_data, &amp;detector_data, &amp;mfp_table_data,  <span class="comment">/*Variables GPU constant memory*/</span>
<a name="l00311"></a>00311         voxel_mat_dens, &amp;voxel_mat_dens_device, voxel_mat_dens_bytes,                          <span class="comment">/*Variables GPU global memory*/</span>
<a name="l00312"></a>00312         image, &amp;image_device, image_bytes,
<a name="l00313"></a>00313         mfp_Woodcock_table, &amp;mfp_Woodcock_table_device, mfp_Woodcock_table_bytes,
<a name="l00314"></a>00314         mfp_table_a, mfp_table_b, &amp;mfp_table_a_device, &amp;mfp_table_b_device, mfp_table_bytes,
<a name="l00315"></a>00315         &amp;rayleigh_table, &amp;rayleigh_table_device,
<a name="l00316"></a>00316         &amp;compton_table, &amp;compton_table_device);
<a name="l00317"></a>00317 <span class="preprocessor">#endif</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span>
<a name="l00319"></a>00319   clock_end = clock();
<a name="l00320"></a>00320   <span class="keywordtype">double</span> time_elapsed_1 = ((double)(clock_end-clock_start))/CLOCKS_PER_SEC;
<a name="l00321"></a>00321   <span class="keywordtype">double</span> time_elapsed_2 = 0.0, time_total = 0.0;
<a name="l00322"></a>00322   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n    -- INITIALIZATION finished: elapsed time = %.3f s\n"</span>, time_elapsed_1);
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="preprocessor">#ifdef USING_MPI</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span>  fflush(stdout);
<a name="l00326"></a>00326   MPI_Barrier(MPI_COMM_WORLD);   <span class="comment">// Synchronize MPI threads before starting the MC phase.</span>
<a name="l00327"></a>00327 <span class="preprocessor">#endif</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span>
<a name="l00329"></a>00329   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n\n    -- MONTE CARLO LOOP phase:\n\n"</span>);
<a name="l00330"></a>00330   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> fflush(stdout);   <span class="comment">// Clear the screen output buffer</span>
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   <span class="comment">// -- Scale the input number of particles taking into account that "histories_per_thread" tracks will be</span>
<a name="l00333"></a>00333   <span class="comment">//    simulated for each call to "track_particles", ie, each GPU thread.</span>
<a name="l00334"></a>00334   <span class="comment">//    The total number of particles simulated will be increased to the nearest multiple histories_per_thread.</span>
<a name="l00335"></a>00335   <span class="keywordflow">if</span>(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>)(total_histories/histories_per_thread))&gt;=2147483647)
<a name="l00336"></a>00336   {
<a name="l00337"></a>00337     <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n\n   !!ERROR!! \"total_histories/histories_per_thread = %lld &gt; 2147483647\": this value can not be represented with a 4 byte integer.\n     Please, increase histories_per_thread until the fraction is acceptable. Sorry about that.\n\n"</span>, ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>)(total_histories/histories_per_thread)));
<a name="l00338"></a>00338     exit(-1);
<a name="l00339"></a>00339   }
<a name="l00340"></a>00340   <span class="keywordtype">int</span> total_history_batch = (int)(total_histories/histories_per_thread);
<a name="l00341"></a>00341   <span class="keywordflow">if</span> (0!=(total_histories%histories_per_thread))
<a name="l00342"></a>00342   {
<a name="l00343"></a>00343     total_history_batch++;        <span class="comment">// Input value is not multiple of HISTORIES_PER_THREAD: make an extra iteration</span>
<a name="l00344"></a>00344     total_histories = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)total_history_batch*histories_per_thread;   <span class="comment">// Total histories will be higher than input value</span>
<a name="l00345"></a>00345   }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 
<a name="l00348"></a>00348   <span class="comment">// *** CT simulation: simulate multiple projections if requested:</span>
<a name="l00349"></a>00349 
<a name="l00350"></a>00350   <span class="keywordtype">double</span> current_angle;
<a name="l00351"></a>00351   <span class="keywordtype">int</span> num_p;  <span class="comment">// == current projection number</span>
<a name="l00352"></a>00352   <span class="keywordflow">for</span> (num_p=0; num_p&lt;num_projections; num_p++)
<a name="l00353"></a>00353   {
<a name="l00354"></a>00354 <span class="preprocessor">    #ifdef USING_MPI</span>
<a name="l00355"></a>00355 <span class="preprocessor"></span>      <span class="comment">// -- Distribute the projections to the multiple threads evenly: each thread simulates an angle and skip the following 'numprocs' angles</span>
<a name="l00356"></a>00356       <span class="keywordflow">if</span>( (num_p % numprocs) != myID )
<a name="l00357"></a>00357       {
<a name="l00358"></a>00358         <span class="comment">// printf(" ... Thread %d skipped projection=%d, modulo=%d\n", myID, num_p, (num_p % numprocs));</span>
<a name="l00359"></a>00359         <span class="keywordflow">continue</span>;
<a name="l00360"></a>00360       }
<a name="l00361"></a>00361 <span class="preprocessor">    #endif</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>    
<a name="l00363"></a>00363     <span class="comment">// -- Check if this projection is inside the angular region of interest</span>
<a name="l00364"></a>00364     current_angle = initial_angle + num_p * D_angle;    
<a name="l00365"></a>00365     <span class="keywordflow">if</span> (current_angle&lt;0.0)
<a name="l00366"></a>00366       current_angle += 2.0*PI;   <span class="comment">// Make sure the angle is not negative.</span>
<a name="l00367"></a>00367     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (current_angle&gt;=(2.0*PI-0.0001))
<a name="l00368"></a>00368       current_angle -= 2.0*PI;   <span class="comment">// Make sure the angle is not above or equal to 360 degrees.</span>
<a name="l00369"></a>00369 
<a name="l00370"></a>00370     <span class="keywordflow">if</span> ((current_angle &lt; angularROI_0) || (current_angle &gt; angularROI_1))
<a name="l00371"></a>00371     {
<a name="l00372"></a>00372       printf(<span class="stringliteral">"\n         &lt;&lt; Skipping projection #%d &gt;&gt; Angle: %f degrees --&gt; outside the angular region of interest.\n"</span>, num_p, current_angle*RAD2DEG);
<a name="l00373"></a>00373       <span class="keywordflow">continue</span>;   <span class="comment">// Cycle loop: do not simulate this projection!</span>
<a name="l00374"></a>00374     }
<a name="l00375"></a>00375       
<a name="l00376"></a>00376     <span class="keywordflow">if</span> (num_projections!=1)
<a name="l00377"></a>00377       printf(<span class="stringliteral">"\n   &lt;&lt; Simulating Projection %d of %d &gt;&gt; Angle: %lf degrees.\n\n"</span>, num_p, num_projections-1, current_angle*RAD2DEG);
<a name="l00378"></a>00378       
<a name="l00379"></a>00379 <span class="preprocessor">    #ifdef USING_CUDA</span>
<a name="l00380"></a>00380 <span class="preprocessor"></span>      <span class="comment">// --Executing the kernel in the GPU:</span>
<a name="l00381"></a>00381       <span class="keywordtype">int</span> total_history_batch_blocks = (int)(total_history_batch/num_threads_per_block);
<a name="l00382"></a>00382       <span class="keywordflow">if</span> (0!=(total_history_batch%num_threads_per_block))
<a name="l00383"></a>00383       {
<a name="l00384"></a>00384         total_history_batch_blocks++;        <span class="comment">// Value is not multiple of num_threads: execute an extra block of threads</span>
<a name="l00385"></a>00385         total_histories = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)total_history_batch_blocks*num_threads_per_block*histories_per_thread;   <span class="comment">// Total histories will be higher than input value</span>
<a name="l00386"></a>00386       }
<a name="l00387"></a>00387       <span class="comment">// -- Setup the execution parameters, taking into account the current CUDA specifications:</span>
<a name="l00388"></a>00388       <span class="comment">//    Warp size: 32, Max number threads per block: 512, Max sizes each dimension of block: 512x512x64, Max sizes each dimension of grid: 65535x65535x1</span>
<a name="l00389"></a>00389       <span class="keywordflow">if</span> (total_history_batch_blocks&gt;65535)
<a name="l00390"></a>00390       {
<a name="l00391"></a>00391         <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n\n   !!ERROR!! \"total_histories/histories_per_thread/num_threads_per_block ~ %d &gt; 65535\": the GPU can not simulate so many blocks (with a 1D grid).\n             Please, increase histories_per_thread or num_threads_per_block until the fraction is acceptable. Sorry about that.\n\n"</span>, total_history_batch_blocks);
<a name="l00392"></a>00392         exit(-1);
<a name="l00393"></a>00393       }
<a name="l00394"></a>00394       dim3 blocks(total_history_batch_blocks, 1);
<a name="l00395"></a>00395       dim3 threads(num_threads_per_block, 1);
<a name="l00396"></a>00396       printf(<span class="stringliteral">"       Executing %d blocks of %d threads, with %d histories in each thread: %lld histories in total.\n"</span>, total_history_batch_blocks, num_threads_per_block, histories_per_thread, total_histories);
<a name="l00397"></a>00397       fflush(stdout); 
<a name="l00398"></a>00398 
<a name="l00399"></a>00399       <span class="comment">// -- Execute the kernel</span>
<a name="l00400"></a>00400       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timer = 0;
<a name="l00401"></a>00401       cutilCheckError(cutCreateTimer(&amp;timer));
<a name="l00402"></a>00402       cutilCheckError(cutStartTimer(timer));
<a name="l00403"></a>00403 
<a name="l00404"></a>00404       clock_start = clock();
<a name="l00405"></a>00405       track_particles&lt;&lt;&lt;blocks,threads&gt;&gt;&gt;(histories_per_thread, num_p, seed_input, image_device, voxel_mat_dens_device, mfp_Woodcock_table_device, mfp_table_a_device, mfp_table_b_device, rayleigh_table_device, compton_table_device);
<a name="l00406"></a>00406       cudaThreadSynchronize();    <span class="comment">// Force the runtime to wait until all device tasks have completed</span>
<a name="l00407"></a>00407 
<a name="l00408"></a>00408       <span class="comment">// -- Check if kernel execution generated any error:</span>
<a name="l00409"></a>00409       cutilCheckMsg(<span class="stringliteral">" !!Kernel execution failed while simulating particle tracks!! "</span>);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411       cutilCheckError( cutStopTimer( timer));
<a name="l00412"></a>00412       printf(<span class="stringliteral">"       ==&gt; CUDA: Kernel execution time in the device: %.3f s \n"</span>, 0.001f*cutGetTimerValue( timer));
<a name="l00413"></a>00413       cutilCheckError( cutDeleteTimer( timer));
<a name="l00414"></a>00414       cutilCheckError( cutCreateTimer( &amp;timer));
<a name="l00415"></a>00415       cutilCheckError( cutStartTimer( timer));
<a name="l00416"></a>00416       cutilSafeCall( cudaMemcpy( image, image_device, image_bytes, cudaMemcpyDeviceToHost) );  <span class="comment">// Copy final results to host</span>
<a name="l00417"></a>00417       cutilCheckError( cutStopTimer( timer));
<a name="l00418"></a>00418       printf(<span class="stringliteral">"                 Time copying results from device to host: %.3f s\n"</span>, 0.001f*cutGetTimerValue( timer));
<a name="l00419"></a>00419       cutilCheckError( cutDeleteTimer( timer));
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 <span class="preprocessor">    #else</span>
<a name="l00422"></a>00422 <span class="preprocessor"></span>      <span class="comment">// --Executing the kernel in the CPU:</span>
<a name="l00423"></a>00423       printf(<span class="stringliteral">"       Executing %d history batches, with %d histories in each batch: %lld histories in total.\n"</span>, total_history_batch, histories_per_thread, total_histories);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425       <span class="comment">// -- Copy local structures to global struct variables accessible from "track_particles" (__constant__ variables in the GPU):</span>
<a name="l00426"></a>00426       <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a> = source_data;
<a name="l00427"></a>00427       <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a> = detector_data;
<a name="l00428"></a>00428       <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a> = voxel_data;
<a name="l00429"></a>00429       <a class="code" href="MC-GPU__v1_81_8h.html#8a3e410fb23d04f8a27d3d71c2381d24" title="Global variable to be stored in the GPU constant memory defining the linear interpolation...">mfp_table_data_CONST</a> = mfp_table_data;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431       clock_start = clock();
<a name="l00432"></a>00432       <span class="keywordtype">int</span> n;
<a name="l00433"></a>00433       <span class="keywordflow">for</span>(n=0; n&lt;total_history_batch; n++)
<a name="l00434"></a>00434       {
<a name="l00435"></a>00435         <span class="comment">// -- Simulate a particle track initializing the PRNG with the particle number 'n':</span>
<a name="l00436"></a>00436         <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#bca9364385e0606e5a89c50ff0e8d54a" title="Main function to simulate x-ray tracks inside a voxelized geometry.">track_particles</a>(n, histories_per_thread, num_p, seed_input, image, voxel_mat_dens, mfp_Woodcock_table, mfp_table_a, mfp_table_b, &amp;rayleigh_table, &amp;compton_table);
<a name="l00437"></a>00437       }
<a name="l00438"></a>00438 <span class="preprocessor">    #endif</span>
<a name="l00439"></a>00439 <span class="preprocessor"></span>
<a name="l00440"></a>00440     <span class="comment">// Get final time and calculate loop execution time:</span>
<a name="l00441"></a>00441     clock_end = clock();
<a name="l00442"></a>00442     time_elapsed_2 = ((double)(clock_end-clock_start))/CLOCKS_PER_SEC;
<a name="l00443"></a>00443     time_total += time_elapsed_2;   <span class="comment">// Count total time (in seconds).</span>
<a name="l00444"></a>00444         <span class="comment">//  printf("\n    -- MONTE CARLO LOOP finished: time tallied in MAIN program: %.3f s\n\n", time_elapsed_2);</span>
<a name="l00445"></a>00445 
<a name="l00446"></a>00446     <span class="comment">// *** Report the final results:</span>
<a name="l00447"></a>00447     <span class="keywordtype">char</span> file_name_output_num_p[253];
<a name="l00448"></a>00448     <span class="keywordflow">if</span> (1==num_projections)
<a name="l00449"></a>00449       strcpy(file_name_output_num_p, file_name_output);   <span class="comment">// Use the input name for single projection</span>
<a name="l00450"></a>00450     <span class="keywordflow">else</span>
<a name="l00451"></a>00451       sprintf(file_name_output_num_p, <span class="stringliteral">"%s_%03d"</span>, file_name_output, num_p);   <span class="comment">// Create the output file name with the input name + projection number (3 digits, padding with 0)</span>
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     <a class="code" href="MC-GPU__v1_81_8cu.html#39db69f5efdcc4012bddf911e8a78691" title="Report the final results, from the host CPU.">report_host</a>(file_name_output_num_p, &amp;detector_data, &amp;source_data, image, time_elapsed_2, total_histories, num_p, num_projections, D_angle, initial_angle, myID, numprocs);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     <span class="comment">// *** Clear the image after reporting, unless this is the last projection to simulate:</span>
<a name="l00456"></a>00456     <span class="keywordflow">if</span> (num_p&lt;(num_projections-1))
<a name="l00457"></a>00457     {
<a name="l00458"></a>00458       <span class="keywordtype">int</span> pixels_per_image = detector_data.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x * detector_data.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y;
<a name="l00459"></a>00459 <span class="preprocessor">      #ifdef USING_CUDA</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span>        printf(<span class="stringliteral">"       ==&gt; CUDA: Launching kernel to reset the device image to 0: number of blocks = %d, threads per block = 128\n"</span>, (<span class="keywordtype">int</span>)ceil(pixels_per_image/128.0f) );
<a name="l00461"></a>00461         <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#0ea66eae6d288c9e4d2456ee1033429f" title="Initialize the image array, ie, set all pixels to zero Essentially, this function...">init_image_array_GPU</a>&lt;&lt;&lt;(int)(ceil(pixels_per_image/128.0f)),128&gt;&gt;&gt;(image_device, pixels_per_image);
<a name="l00462"></a>00462         cudaThreadSynchronize();
<a name="l00463"></a>00463         cutilCheckMsg(<span class="stringliteral">" !!Kernel execution failed initializing the image array!! "</span>);  <span class="comment">// Check if kernel execution generated any error:</span>
<a name="l00464"></a>00464 <span class="preprocessor">      #else</span>
<a name="l00465"></a>00465 <span class="preprocessor"></span>        <span class="keywordtype">int</span> j;
<a name="l00466"></a>00466         <span class="keywordflow">for</span> (j=0; j&lt;pixels_per_image; j++)   <span class="comment">// INIT IMAGE ARRAY IN THE CPU</span>
<a name="l00467"></a>00467         {
<a name="l00468"></a>00468           image[j                   ] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);
<a name="l00469"></a>00469           image[j+  pixels_per_image] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);
<a name="l00470"></a>00470           image[j+2*pixels_per_image] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);
<a name="l00471"></a>00471           image[j+3*pixels_per_image] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);
<a name="l00472"></a>00472         }
<a name="l00473"></a>00473 <span class="preprocessor">      #endif</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span>    }
<a name="l00475"></a>00475   }  <span class="comment">// [Loop end: iterate for next CT projection]</span>
<a name="l00476"></a>00476 
<a name="l00477"></a>00477   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n    -- MONTE CARLO LOOP finished: total time tallied in MAIN program: %.3f s\n"</span>, time_total);
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   <span class="comment">// *** Clean up RAM memory:</span>
<a name="l00481"></a>00481   free(voxel_mat_dens);
<a name="l00482"></a>00482   free(image);
<a name="l00483"></a>00483   free(mfp_Woodcock_table);
<a name="l00484"></a>00484   free(mfp_table_a);
<a name="l00485"></a>00485   free(mfp_table_b);
<a name="l00486"></a>00486   
<a name="l00487"></a>00487 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00488"></a>00488 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timer = 0;
<a name="l00489"></a>00489   cutilCheckError( cutCreateTimer( &amp;timer));
<a name="l00490"></a>00490   cutilCheckError( cutStartTimer( timer));
<a name="l00491"></a>00491   
<a name="l00492"></a>00492   <span class="comment">// -- Clean up GPU device memory:</span>
<a name="l00493"></a>00493   cutilSafeCall(cudaFree(voxel_mat_dens_device));
<a name="l00494"></a>00494   cutilSafeCall(cudaFree(image_device));
<a name="l00495"></a>00495   cutilSafeCall(cudaFree(mfp_Woodcock_table_device));
<a name="l00496"></a>00496   cutilSafeCall(cudaFree(mfp_table_a_device));
<a name="l00497"></a>00497   cutilSafeCall(cudaFree(mfp_table_b_device));
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   cudaThreadExit();
<a name="l00500"></a>00500 
<a name="l00501"></a>00501   cutilCheckError( cutStopTimer( timer));
<a name="l00502"></a>00502   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       ==&gt; CUDA: Time freeing the device memory and ending the GPU threads: %.6f s\n"</span>, 0.001f*cutGetTimerValue( timer));
<a name="l00503"></a>00503   cutilCheckError( cutDeleteTimer( timer));
<a name="l00504"></a>00504 <span class="preprocessor">#endif</span>
<a name="l00505"></a>00505 <span class="preprocessor"></span>
<a name="l00506"></a>00506 <span class="preprocessor">#ifdef USING_MPI</span>
<a name="l00507"></a>00507 <span class="preprocessor"></span>  current_time=time(NULL);     <span class="comment">// Get current time (in seconds)</span>
<a name="l00508"></a>00508   printf(<span class="stringliteral">"       MPI node %d done! Time: %s\n"</span>, myID, ctime(&amp;current_time));
<a name="l00509"></a>00509   fflush(stdout);   <span class="comment">// Clear the screen output buffer</span>
<a name="l00510"></a>00510   MPI_Barrier(MPI_COMM_WORLD);   <span class="comment">// Synchronize MPI threads</span>
<a name="l00511"></a>00511   MPI_Finalize();   <span class="comment">// Finalize MPI library: no more MPI calls allowed below.</span>
<a name="l00512"></a>00512 <span class="preprocessor">#endif</span>
<a name="l00513"></a>00513 <span class="preprocessor"></span>
<a name="l00514"></a>00514   current_time=time(NULL);     <span class="comment">// Get current time (in seconds)</span>
<a name="l00515"></a>00515   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n****** Code execution finished on: %s\n"</span>, ctime(&amp;current_time));
<a name="l00516"></a>00516   
<a name="l00517"></a>00517   <span class="keywordflow">return</span> 0;
<a name="l00518"></a>00518 }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 <span class="comment"></span>
<a name="l00522"></a>00522 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00523"></a>00523 <span class="comment">//! Read the input file given in the command line and return the significant data.</span>
<a name="l00524"></a>00524 <span class="comment">//! Example input file:</span>
<a name="l00525"></a>00525 <span class="comment">//!</span>
<a name="l00526"></a>00526 <span class="comment">//!    1000000          [Total number of histories to simulate]</span>
<a name="l00527"></a>00527 <span class="comment">//!    geometry.vox     [Voxelized geometry file name]</span>
<a name="l00528"></a>00528 <span class="comment">//!    material.mat     [Material data file name]</span>
<a name="l00529"></a>00529 <span class="comment">//!</span>
<a name="l00530"></a>00530 <span class="comment">//!       @param[in] argc   Command line parameters</span>
<a name="l00531"></a>00531 <span class="comment">//!       @param[in] argv   Command line parameters: name opf input file</span>
<a name="l00532"></a>00532 <span class="comment">//!       @param[out] total_histories  Total number of particles to simulate</span>
<a name="l00533"></a>00533 <span class="comment">//!       @param[out] seed_input   Input random number generator seed</span>
<a name="l00534"></a>00534 <span class="comment">//!       @param[out] num_threads_per_block   Number of CUDA threads for each GPU block</span>
<a name="l00535"></a>00535 <span class="comment">//!       @param[out] detector_data</span>
<a name="l00536"></a>00536 <span class="comment">//!       @param[out] image</span>
<a name="l00537"></a>00537 <span class="comment">//!       @param[out] source_data</span>
<a name="l00538"></a>00538 <span class="comment">//!       @param[out] file_name_voxels</span>
<a name="l00539"></a>00539 <span class="comment">//!       @param[out] file_name_materials</span>
<a name="l00540"></a>00540 <span class="comment">//!       @param[out] file_name_output</span>
<a name="l00541"></a>00541 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00542"></a><a class="code" href="MC-GPU__v1_81_8h.html#a2f5da38f6311a306a4fac637f8872bb">00542</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="MC-GPU__v1_81_8cu.html#5cd97f26e0582ba1236d387bd8b9d2e5" title="Read the input file given in the command line and return the significant data.">read_input</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv, <span class="keywordtype">int</span> myID, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>* total_histories, <span class="keywordtype">int</span>* seed_input, <span class="keywordtype">int</span>* gpu_id, <span class="keywordtype">int</span>* num_threads_per_block, <span class="keywordtype">int</span>* histories_per_thread, <span class="keyword">struct</span> <a class="code" href="structdetector__struct.html" title="Structure storing the data defining the x-ray detector.">detector_struct</a>* detector_data, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>** image_ptr, <span class="keywordtype">int</span>* image_bytes, <span class="keyword">struct</span> <a class="code" href="structsource__struct.html" title="Structure storing the data defining the source model.">source_struct</a>* source_data, <span class="keywordtype">char</span>* file_name_voxels, <span class="keywordtype">char</span> file_name_materials[<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>][250] , <span class="keywordtype">char</span>* file_name_output, <span class="keywordtype">int</span>* num_projections, <span class="keywordtype">double</span>* D_angle, <span class="keywordtype">double</span>* angularROI_0, <span class="keywordtype">double</span>* angularROI_1, <span class="keywordtype">double</span>* initial_angle)
<a name="l00543"></a>00543 {
<a name="l00544"></a>00544   FILE* file_ptr = NULL;
<a name="l00545"></a>00545   <span class="keywordtype">char</span> new_line[250];
<a name="l00546"></a>00546   <span class="keywordtype">char</span> *new_line_ptr = NULL;
<a name="l00547"></a>00547   <span class="keywordtype">double</span> dummy_double;
<a name="l00548"></a>00548 
<a name="l00549"></a>00549   <span class="comment">// -- Read the input file name from command line, if given (otherwise keep default value):</span>
<a name="l00550"></a>00550   <span class="keywordflow">if</span> (2==argc)
<a name="l00551"></a>00551   {
<a name="l00552"></a>00552     file_ptr = fopen(argv[1], <span class="stringliteral">"r"</span>);
<a name="l00553"></a>00553     <span class="keywordflow">if</span> (NULL==file_ptr)
<a name="l00554"></a>00554     {
<a name="l00555"></a>00555       printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Input file not found or not readable. Input file name: \'%s\'\n\n"</span>, argv[1]);
<a name="l00556"></a>00556       exit(-1);
<a name="l00557"></a>00557     }
<a name="l00558"></a>00558   }
<a name="l00559"></a>00559   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argc&gt;2)
<a name="l00560"></a>00560   {
<a name="l00561"></a>00561     printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Too many input parameter (argc=%d)!! Provide only the input file name.\n\n"</span>, argc);
<a name="l00562"></a>00562     exit(-1);
<a name="l00563"></a>00563   }
<a name="l00564"></a>00564   <span class="keywordflow">else</span>
<a name="l00565"></a>00565   {
<a name="l00566"></a>00566     printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Input file name not given as an execution parameter!! Try again...\n\n"</span>);
<a name="l00567"></a>00567     exit(-1);
<a name="l00568"></a>00568   }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n    -- Reading the input file \'%s\':\n"</span>, argv[1]);
<a name="l00571"></a>00571 
<a name="l00572"></a>00572   <span class="keywordflow">do</span>
<a name="l00573"></a>00573   {
<a name="l00574"></a>00574     new_line_ptr = fgets(new_line, 250, file_ptr);    <span class="comment">// Read full line (max. 250 characters).</span>
<a name="l00575"></a>00575     <span class="keywordflow">if</span> (new_line_ptr==NULL)
<a name="l00576"></a>00576     {
<a name="l00577"></a>00577       printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Input file is not readable or does not contain the string \'SECTION SIMULATION\'!!\n"</span>);
<a name="l00578"></a>00578       exit(-2);
<a name="l00579"></a>00579     }
<a name="l00580"></a>00580   }
<a name="l00581"></a>00581   <span class="keywordflow">while</span>(strstr(new_line,<span class="stringliteral">"SECTION SIMULATION"</span>)==NULL);   <span class="comment">// Skip comments and empty lines until the section begins</span>
<a name="l00582"></a>00582   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00583"></a>00583     sscanf(new_line, <span class="stringliteral">"%lf"</span>, &amp;dummy_double);
<a name="l00584"></a>00584     *total_histories = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int) (dummy_double+0.0001);  <span class="comment">// Maximum unsigned long long value: 18446744073709551615</span>
<a name="l00585"></a>00585   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00586"></a>00586     sscanf(new_line, <span class="stringliteral">"%d"</span>, seed_input);   <span class="comment">// Set the RANECU PRNG seed (the same seed will be used to init the 2 MLCGs in RANECU)</span>
<a name="l00587"></a>00587   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00588"></a>00588     sscanf(new_line, <span class="stringliteral">"%d"</span>, gpu_id);       <span class="comment">// GPU NUMBER WHERE SIMULATION WILL RUN</span>
<a name="l00589"></a>00589   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00590"></a>00590     sscanf(new_line, <span class="stringliteral">"%d"</span>, num_threads_per_block);  <span class="comment">// GPU THREADS PER CUDA BLOCK</span>
<a name="l00591"></a>00591   <span class="keywordflow">if</span> ((*num_threads_per_block%32)!=0)
<a name="l00592"></a>00592   {
<a name="l00593"></a>00593     printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! The input number of GPU threads per CUDA block must be a multiple of 32 (warp size). Input value: %d !!\n\n"</span>, *num_threads_per_block);
<a name="l00594"></a>00594     exit(-2);
<a name="l00595"></a>00595   }
<a name="l00596"></a>00596   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00597"></a>00597     sscanf(new_line, <span class="stringliteral">"%d"</span>, histories_per_thread);   <span class="comment">// HISTORIES PER GPU THREAD</span>
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   <span class="keywordflow">do</span>
<a name="l00600"></a>00600   {
<a name="l00601"></a>00601     new_line_ptr = fgets(new_line, 250, file_ptr);
<a name="l00602"></a>00602     <span class="keywordflow">if</span> (new_line_ptr==NULL)
<a name="l00603"></a>00603     {
<a name="l00604"></a>00604       printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Input file is not readable or does not contain the string \'SECTION SOURCE\'!!\n"</span>);
<a name="l00605"></a>00605       exit(-2);
<a name="l00606"></a>00606     }
<a name="l00607"></a>00607   }
<a name="l00608"></a>00608   <span class="keywordflow">while</span>(strstr(new_line,<span class="stringliteral">"SECTION SOURCE"</span>)==NULL);   <span class="comment">// Skip comments and empty lines until the section begins</span>
<a name="l00609"></a>00609   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00610"></a>00610     sscanf(new_line, <span class="stringliteral">"%f"</span>, &amp;(source_data-&gt;<a class="code" href="structsource__struct.html#9e48c14733a7848fa9e038088c18847a">energy</a>));  <span class="comment">// X-RAY ENERGY [eV]</span>
<a name="l00611"></a>00611   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00612"></a>00612     sscanf(new_line, <span class="stringliteral">"%f %f %f"</span>, &amp;source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].x, &amp;source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].y, &amp;source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].z);   <span class="comment">// SOURCE POSITION: X Y Z [cm]</span>
<a name="l00613"></a>00613   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00614"></a>00614     sscanf(new_line, <span class="stringliteral">"%f %f %f"</span>, &amp;source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x, &amp;source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y, &amp;source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z);   <span class="comment">// SOURCE DIRECTION COSINES: U V W</span>
<a name="l00615"></a>00615     <span class="comment">// -- Normalize the input beam direction to 1:</span>
<a name="l00616"></a>00616     dummy_double = 1.0/sqrt((<span class="keywordtype">double</span>)(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z));
<a name="l00617"></a>00617     source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x = (float)(((<span class="keywordtype">double</span>)source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x)*dummy_double);
<a name="l00618"></a>00618     source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y = (float)(((<span class="keywordtype">double</span>)source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y)*dummy_double);
<a name="l00619"></a>00619     source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z = (float)(((<span class="keywordtype">double</span>)source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z)*dummy_double);
<a name="l00620"></a>00620   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00621"></a>00621   
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 <span class="comment">/* !!DeBuG!! OLD WRONG FAN BEAM:  </span>
<a name="l00624"></a>00624 <span class="comment">    sscanf(new_line, "%f %f", &amp;source_data-&gt;tan_phi_semiaperture, &amp;source_data-&gt;tan_theta_semiaperture);</span>
<a name="l00625"></a>00625 <span class="comment">    if ( (source_data-&gt;tan_phi_semiaperture&gt;-1.0e-6) &amp;&amp; (source_data-&gt;tan_theta_semiaperture&gt;-1.0e-6) )   // If we enter a negative angle, the fan beam will cover exactly the detector surface (see below).</span>
<a name="l00626"></a>00626 <span class="comment">    {</span>
<a name="l00627"></a>00627 <span class="comment">      source_data-&gt;tan_phi_semiaperture   = tan(0.5 * source_data-&gt;tan_phi_semiaperture*DEG2RAD);    // Divide by 2 the input apertures to get semiapertures.</span>
<a name="l00628"></a>00628 <span class="comment">      source_data-&gt;tan_theta_semiaperture = tan(0.5 * source_data-&gt;tan_theta_semiaperture*DEG2RAD);  // The tan of the semiaperture is the size of the field at distance 1, where we will sample uniform points.</span>
<a name="l00629"></a>00629 <span class="comment">    }</span>
<a name="l00630"></a>00630 <span class="comment">*/</span>
<a name="l00631"></a>00631 
<a name="l00632"></a>00632 
<a name="l00633"></a>00633   <span class="comment">// Read input fan beam polar (theta) and azimuthal (phi) aperture angles (deg):</span>
<a name="l00634"></a>00634   <span class="keywordtype">double</span> phi_aperture, theta_aperture;
<a name="l00635"></a>00635   sscanf(new_line, <span class="stringliteral">"%lf %lf"</span>, &amp;phi_aperture, &amp;theta_aperture);
<a name="l00636"></a>00636 
<a name="l00637"></a>00637   <span class="keywordflow">if</span> (theta_aperture &gt; 180.0)
<a name="l00638"></a>00638   {
<a name="l00639"></a>00639     printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Input polar aperture must be in [0,180] deg.!\n"</span>);
<a name="l00640"></a>00640     printf(<span class="stringliteral">"                       theta_aperture = %lf, phi_aperture = %lf\n"</span>, theta_aperture, phi_aperture);
<a name="l00641"></a>00641     exit(-2);
<a name="l00642"></a>00642   }
<a name="l00643"></a>00643   <span class="keywordflow">if</span> (phi_aperture &gt; 360.0)
<a name="l00644"></a>00644   {
<a name="l00645"></a>00645     printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Input azimuthal aperture must be in [0,360] deg.!\n"</span>);
<a name="l00646"></a>00646     printf(<span class="stringliteral">"                       theta_aperture = %lf, phi_aperture = %lf\n"</span>, theta_aperture, phi_aperture);
<a name="l00647"></a>00647     exit(-2);
<a name="l00648"></a>00648   }
<a name="l00649"></a>00649   <span class="comment">// Entering a negative theta_aperture or phi_aperture, the emitted fan beam will cover exactly the detector: see below</span>
<a name="l00650"></a>00650   
<a name="l00651"></a>00651   <span class="comment">// *** RECTANGULAR BEAM INITIALIZATION: aperture initially centered at (0,1,0), ie, THETA_0=90, PHI_0=90</span>
<a name="l00652"></a>00652   <span class="comment">//     Using the algorithm used in PENMAIN.f, from penelope 2008 (by F. Salvat).</span>
<a name="l00653"></a>00653   source_data-&gt;<a class="code" href="structsource__struct.html#d3b7a93633ec87d036453e54e7e7abad">cos_theta_low</a> = (float)( cos((90.0 - 0.5*theta_aperture)*DEG2RAD) );
<a name="l00654"></a>00654   source_data-&gt;<a class="code" href="structsource__struct.html#942289f702f8fc1c6acd411c8ff19efe">D_cos_theta</a>   = (float)( -2.0*source_data-&gt;<a class="code" href="structsource__struct.html#d3b7a93633ec87d036453e54e7e7abad">cos_theta_low</a> );      <span class="comment">// Theta aperture is symetric above and below 90 deg</span>
<a name="l00655"></a>00655   source_data-&gt;<a class="code" href="structsource__struct.html#22bb360d294d1a3236e8ba8c4b6d06aa">phi_low</a>       = (float)( (90.0 - 0.5*phi_aperture)*DEG2RAD );
<a name="l00656"></a>00656   source_data-&gt;<a class="code" href="structsource__struct.html#01b06b35c2bc440ad0091dddde0cad06">D_phi</a>         = (float)( phi_aperture*DEG2RAD );
<a name="l00657"></a>00657 
<a name="l00658"></a>00658   source_data-&gt;<a class="code" href="structsource__struct.html#b1bdb59150b1b055e9149461bc090cf4">max_height_at_y1cm</a> = (float) ( tan(0.5*theta_aperture*DEG2RAD) );  <span class="comment">//!!DeBuG!! Force square field for any phi!!</span>
<a name="l00659"></a>00659 <span class="comment"></span>      
<a name="l00660"></a>00660 
<a name="l00661"></a>00661 printf(<span class="stringliteral">"\n\n  !!DeBuG!! cos_theta_low=%f, D_cos_theta=%f, phi_low=%f, D_phi=%f\n\n"</span>, source_data-&gt;<a class="code" href="structsource__struct.html#d3b7a93633ec87d036453e54e7e7abad">cos_theta_low</a>, source_data-&gt;<a class="code" href="structsource__struct.html#942289f702f8fc1c6acd411c8ff19efe">D_cos_theta</a>, source_data-&gt;<a class="code" href="structsource__struct.html#22bb360d294d1a3236e8ba8c4b6d06aa">phi_low</a>, source_data-&gt;<a class="code" href="structsource__struct.html#01b06b35c2bc440ad0091dddde0cad06">D_phi</a>);
<a name="l00662"></a>00662 
<a name="l00663"></a>00663   <span class="keywordflow">do</span>
<a name="l00664"></a>00664   {
<a name="l00665"></a>00665     new_line_ptr = fgets(new_line, 250, file_ptr);
<a name="l00666"></a>00666     <span class="keywordflow">if</span> (new_line_ptr==NULL)
<a name="l00667"></a>00667     {
<a name="l00668"></a>00668       printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Input file is not readable or does not contain the string \'SECTION DETECTOR\'!!\n"</span>);
<a name="l00669"></a>00669       exit(-2);
<a name="l00670"></a>00670     }
<a name="l00671"></a>00671   }
<a name="l00672"></a>00672   <span class="keywordflow">while</span>(strstr(new_line,<span class="stringliteral">"SECTION DETECTOR"</span>)==NULL);   <span class="comment">// Skip comments and empty lines until the section begins</span>
<a name="l00673"></a>00673   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00674"></a>00674     <a class="code" href="MC-GPU__v1_81_8cu.html#96dba25b308814b25fbae71e27617f12" title="Extract a file name from an input text line, trimming the initial blanks, trailing...">trim_name</a>(new_line, file_name_output);   <span class="comment">// OUTPUT IMAGE FILE NAME (no spaces)</span>
<a name="l00675"></a>00675   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00676"></a>00676     sscanf(new_line, <span class="stringliteral">"%d %d"</span>, &amp;detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x, &amp;detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y);   <span class="comment">// NUMBER OF PIXELS IN THE IMAGE: Nx Nz</span>
<a name="l00677"></a>00677     detector_data-&gt;<a class="code" href="structdetector__struct.html#c26d0b66ebf521346d8ba07609340ea6">total_num_pixels</a> = detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x * detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y;
<a name="l00678"></a>00678   
<a name="l00679"></a>00679   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00680"></a>00680   sscanf(new_line, <span class="stringliteral">"%f %f"</span>, &amp;detector_data-&gt;<a class="code" href="structdetector__struct.html#1f67c512205953e75552865ae7a2490a">width_X</a>, &amp;detector_data-&gt;<a class="code" href="structdetector__struct.html#f61592c77c6da548fff31215bf956dd8">height_Z</a>);   <span class="comment">// IMAGE SIZE (width, height): Dx Dz [cm]</span>
<a name="l00681"></a>00681     detector_data-&gt;<a class="code" href="structdetector__struct.html#3c6f9e59e89db06211ccea63287e2826">inv_pixel_size_X</a> = detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x / detector_data-&gt;<a class="code" href="structdetector__struct.html#1f67c512205953e75552865ae7a2490a">width_X</a>;
<a name="l00682"></a>00682     detector_data-&gt;<a class="code" href="structdetector__struct.html#a91fc94f674ad7af8eca577f4d8cd22b">inv_pixel_size_Z</a> = detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y / detector_data-&gt;<a class="code" href="structdetector__struct.html#f61592c77c6da548fff31215bf956dd8">height_Z</a>;
<a name="l00683"></a>00683 
<a name="l00684"></a>00684   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00685"></a>00685     sscanf(new_line, <span class="stringliteral">"%f"</span>, &amp;detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>);            <span class="comment">// SOURCE-TO-DETECTOR DISTANCE [cm] (detector set in front of the source, normal to the input direction)</span>
<a name="l00686"></a>00686 
<a name="l00687"></a>00687     float3 detector_center;   <span class="comment">// Center of the detector straight ahead of the focal spot.</span>
<a name="l00688"></a>00688     detector_center.x = source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].x + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x * detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>;
<a name="l00689"></a>00689     detector_center.y = source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].y + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y * detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>;
<a name="l00690"></a>00690     detector_center.z = source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].z + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z * detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>;
<a name="l00691"></a>00691         
<a name="l00692"></a>00692     <span class="keywordflow">if</span> ((detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>)&lt;1.0e-6)
<a name="l00693"></a>00693     {
<a name="l00694"></a>00694       printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! The source-to-detector distance must be positive. Input: ssd=%f!!\n\n"</span>, detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>);
<a name="l00695"></a>00695       exit(-2);
<a name="l00696"></a>00696     }
<a name="l00697"></a>00697 
<a name="l00698"></a>00698 <span class="comment">/* !!DeBuG!! OLD WRONG FAN BEAM:  </span>
<a name="l00699"></a>00699 <span class="comment">    if ( (source_data-&gt;tan_phi_semiaperture &lt; -1.0e-5) || (source_data-&gt;tan_theta_semiaperture &lt; -1.0e-5) )   // If we enter a negative angle, the fan beam will cover exactly the detector surface.</span>
<a name="l00700"></a>00700 <span class="comment">    {</span>
<a name="l00701"></a>00701 <span class="comment">      source_data-&gt;tan_phi_semiaperture   = 0.5 * detector_data-&gt;width_X  / (detector_data-&gt;sdd);  // Set the aperture to cover the whole detector exactly (detector is at distance ssd, move to 1cm).</span>
<a name="l00702"></a>00702 <span class="comment">      source_data-&gt;tan_theta_semiaperture = 0.5 * detector_data-&gt;height_Z / (detector_data-&gt;sdd);</span>
<a name="l00703"></a>00703 <span class="comment">    }</span>
<a name="l00704"></a>00704 <span class="comment">*/</span>
<a name="l00705"></a>00705   <span class="keywordflow">if</span> ( (theta_aperture &lt; -1.0e-7) || (phi_aperture &lt; -1.0e-7) )   <span class="comment">// If we enter a negative angle, the fan beam will cover exactly the detector surface.</span>
<a name="l00706"></a>00706   {
<a name="l00707"></a>00707     theta_aperture= 2.0 * atan(0.5*detector_data-&gt;<a class="code" href="structdetector__struct.html#f61592c77c6da548fff31215bf956dd8">height_Z</a>/(detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>)) * RAD2DEG;   <span class="comment">// Optimum angles</span>
<a name="l00708"></a>00708     phi_aperture  = 2.0 * atan(0.5*detector_data-&gt;<a class="code" href="structdetector__struct.html#1f67c512205953e75552865ae7a2490a">width_X</a>/(detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>)) * RAD2DEG;
<a name="l00709"></a>00709 
<a name="l00710"></a>00710     source_data-&gt;<a class="code" href="structsource__struct.html#d3b7a93633ec87d036453e54e7e7abad">cos_theta_low</a> = (float)( cos((90.0 - 0.5*theta_aperture)*DEG2RAD) );
<a name="l00711"></a>00711     source_data-&gt;<a class="code" href="structsource__struct.html#942289f702f8fc1c6acd411c8ff19efe">D_cos_theta</a>   = (float)( -2.0*source_data-&gt;<a class="code" href="structsource__struct.html#d3b7a93633ec87d036453e54e7e7abad">cos_theta_low</a> );      <span class="comment">// Theta aperture is symetric above and below 90 deg</span>
<a name="l00712"></a>00712     source_data-&gt;<a class="code" href="structsource__struct.html#22bb360d294d1a3236e8ba8c4b6d06aa">phi_low</a>       = (float)( (90.0 - 0.5*phi_aperture)*DEG2RAD );
<a name="l00713"></a>00713     source_data-&gt;<a class="code" href="structsource__struct.html#01b06b35c2bc440ad0091dddde0cad06">D_phi</a>         = (float)( phi_aperture*DEG2RAD );
<a name="l00714"></a>00714   }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716   <span class="keywordflow">do</span>
<a name="l00717"></a>00717   {
<a name="l00718"></a>00718     new_line_ptr = fgets(new_line, 250, file_ptr);
<a name="l00719"></a>00719     <span class="keywordflow">if</span> (new_line_ptr==NULL)
<a name="l00720"></a>00720     {
<a name="l00721"></a>00721       printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Input file is not readable or does not contain the string \'SECTION CT SCAN\'!!\n"</span>);
<a name="l00722"></a>00722       exit(-2);
<a name="l00723"></a>00723     }
<a name="l00724"></a>00724   }
<a name="l00725"></a>00725   <span class="keywordflow">while</span>(strstr(new_line,<span class="stringliteral">"SECTION CT"</span>)==NULL);  <span class="comment">// Skip comments and empty lines until the section begins</span>
<a name="l00726"></a>00726   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00727"></a>00727   sscanf(new_line, <span class="stringliteral">"%d"</span>, num_projections);     <span class="comment">// NUMBER OF PROJECTIONS (beam must be perpendicular to Z axis)</span>
<a name="l00728"></a>00728   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00729"></a>00729   sscanf(new_line, <span class="stringliteral">"%lf"</span>, D_angle);   <span class="comment">// ANGLE BETWEEN PROJECTIONS [degrees] (360/num_projections for full CT)</span>
<a name="l00730"></a>00730   *D_angle = (*D_angle)*DEG2RAD;      <span class="comment">// store the angle in radians</span>
<a name="l00731"></a>00731 
<a name="l00732"></a>00732   <span class="comment">// Calculate initial source angle:</span>
<a name="l00733"></a>00733   *initial_angle = acos((<span class="keywordtype">double</span>)(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x));
<a name="l00734"></a>00734   <span class="keywordflow">if</span> (source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y&lt;0)
<a name="l00735"></a>00735     *initial_angle = -(*initial_angle);     <span class="comment">// Correct for the fact that positive and negative angles have the same ACOS</span>
<a name="l00736"></a>00736   <span class="keywordflow">if</span> (*initial_angle&lt;0.0)
<a name="l00737"></a>00737     *initial_angle = (*initial_angle) + 2.0*PI;   <span class="comment">// Make sure the angle is not negative, between [0,360) degrees.</span>
<a name="l00738"></a>00738   *initial_angle = (*initial_angle) - PI;   <span class="comment">// Correct the fact that the source is opposite to the detector (180 degrees difference).</span>
<a name="l00739"></a>00739   <span class="keywordflow">if</span> (*initial_angle&lt;0.0)
<a name="l00740"></a>00740     *initial_angle = (*initial_angle) + 2.0*PI;   <span class="comment">// Make sure the initial angle is not negative, between [0,360) degrees..</span>
<a name="l00741"></a>00741 
<a name="l00742"></a>00742   
<a name="l00743"></a>00743   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00744"></a>00744   sscanf(new_line, <span class="stringliteral">"%lf %lf"</span>, angularROI_0, angularROI_1);   <span class="comment">// ANGLES OF INTEREST (projections outside this interval will be skipped)</span>
<a name="l00745"></a>00745   <span class="keywordflow">if</span> (*angularROI_0&lt;-0.001 || *angularROI_1&gt;360.001)
<a name="l00746"></a>00746   {
<a name="l00747"></a>00747     printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! The angles in the angular region of interest must be in the interval [0,360]. Input: %f, %f.\n\n"</span>, *angularROI_0, *angularROI_1);   <span class="comment">// The reconstructed planes are always parallel to the XY plane.\n");</span>
<a name="l00748"></a>00748     exit(-2);
<a name="l00749"></a>00749   }
<a name="l00750"></a>00750   *angularROI_0 = (*angularROI_0 - 0.0001)*DEG2RAD;   <span class="comment">// Store the angles of interest in radians, increasing a little the interval to avoid precission problems</span>
<a name="l00751"></a>00751   *angularROI_1 = (*angularROI_1 + 0.0001)*DEG2RAD;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   
<a name="l00754"></a>00754   <span class="keywordflow">if</span> (0 == (*num_projections))
<a name="l00755"></a>00755     *num_projections = 1;      <span class="comment">// Zero projections has the same effect as 1 projection (ie, no CT scan rotation). Negative values are allowed and the source rotates in opposite rotation.</span>
<a name="l00756"></a>00756   <span class="keywordflow">if</span> ( (fabs(*num_projections) &gt; 1) &amp;&amp; (fabs(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z)&gt;0.00001f) )
<a name="l00757"></a>00757   {
<a name="l00758"></a>00758     printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Sorry, but currently we can only simulate CT scans when the source direction is perpendicular to the Z axis (ie, w=0).\n\n"</span>);   <span class="comment">// The reconstructed planes are always parallel to the XY plane.\n");</span>
<a name="l00759"></a>00759     exit(-2);
<a name="l00760"></a>00760   }
<a name="l00761"></a>00761   
<a name="l00762"></a>00762 
<a name="l00763"></a>00763   <span class="keywordflow">do</span>
<a name="l00764"></a>00764   {
<a name="l00765"></a>00765     new_line_ptr = fgets(new_line, 250, file_ptr);
<a name="l00766"></a>00766     <span class="keywordflow">if</span> (new_line_ptr==NULL)
<a name="l00767"></a>00767     {
<a name="l00768"></a>00768       printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Input file is not readable or does not contain the string \'SECTION VOXELIZED GEOMETRY FILE\'!!\n"</span>);
<a name="l00769"></a>00769       exit(-2);
<a name="l00770"></a>00770     }
<a name="l00771"></a>00771   }
<a name="l00772"></a>00772   <span class="keywordflow">while</span>(strstr(new_line,<span class="stringliteral">"SECTION VOXEL"</span>)==NULL);   <span class="comment">// Skip comments and empty lines until the section begins</span>
<a name="l00773"></a>00773   <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00774"></a>00774   <a class="code" href="MC-GPU__v1_81_8cu.html#96dba25b308814b25fbae71e27617f12" title="Extract a file name from an input text line, trimming the initial blanks, trailing...">trim_name</a>(new_line, file_name_voxels);   <span class="comment">// VOXEL GEOMETRY FILE (penEasy 2008 format)</span>
<a name="l00775"></a>00775 
<a name="l00776"></a>00776   <span class="keywordflow">do</span>
<a name="l00777"></a>00777   {
<a name="l00778"></a>00778     new_line_ptr = fgets(new_line, 250, file_ptr);
<a name="l00779"></a>00779     <span class="keywordflow">if</span> (new_line_ptr==NULL)
<a name="l00780"></a>00780     {
<a name="l00781"></a>00781       printf(<span class="stringliteral">"\n\n   !!read_input ERROR!! Input file is not readable or does not contain the string \'SECTION MATERIAL FILE LIST\'!!\n"</span>);
<a name="l00782"></a>00782       exit(-2);
<a name="l00783"></a>00783     }
<a name="l00784"></a>00784   }
<a name="l00785"></a>00785   <span class="keywordflow">while</span>(strstr(new_line,<span class="stringliteral">"SECTION MATERIAL"</span>)==NULL);   <span class="comment">// Skip comments and empty lines until the section begins</span>
<a name="l00786"></a>00786 
<a name="l00787"></a>00787   <span class="keywordtype">int</span> i;
<a name="l00788"></a>00788   <span class="keywordflow">for</span> (i=0; i&lt;MAX_MATERIALS; i++)
<a name="l00789"></a>00789   {
<a name="l00790"></a>00790     new_line_ptr = <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(new_line, 250, file_ptr);
<a name="l00791"></a>00791     <span class="keywordflow">if</span> (new_line_ptr==NULL)
<a name="l00792"></a>00792       file_name_materials[i][0]=<span class="charliteral">'\n'</span>;   <span class="comment">// The input file is allowed to finish without defining all the materials</span>
<a name="l00793"></a>00793     <span class="keywordflow">else</span>
<a name="l00794"></a>00794       <a class="code" href="MC-GPU__v1_81_8cu.html#96dba25b308814b25fbae71e27617f12" title="Extract a file name from an input text line, trimming the initial blanks, trailing...">trim_name</a>(new_line, file_name_materials[i]);
<a name="l00795"></a>00795   }
<a name="l00796"></a>00796   <span class="comment">// [Finish reading input file]</span>
<a name="l00797"></a>00797 <span class="comment"></span>
<a name="l00798"></a>00798 <span class="comment">  /////////////////////////////////////////////////////////////////////////////</span>
<a name="l00799"></a>00799 <span class="comment"></span>
<a name="l00800"></a>00800   <span class="comment">// *** Set the rotation that will bring particles from the detector plane to +Y=(0,+1,0) through a rotation around X and around Z (counter-clock):</span>
<a name="l00801"></a>00801   <span class="keywordtype">double</span> rotX, rotZ, cos_rX, cos_rZ, sin_rX, sin_rZ;
<a name="l00802"></a>00802       <span class="comment">// rotX = 1.5*PI - acos(source_data-&gt;direction.z);  // Rotate to +Y = (0,+1,0) --&gt; rotX_0 = 3/2*PI == -PI/2</span>
<a name="l00803"></a>00803     rotX = acos(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z) - 0.5*PI;  <span class="comment">// Rotate to +Y = (0,+1,0) --&gt; rotX_0 =  -PI/2</span>
<a name="l00804"></a>00804       <span class="comment">// rotX = 0.5*PI - acos(source_data-&gt;direction.z);  // Rotate to +Y = (0,+1,0) --&gt; rotX_0 =  PI/2</span>
<a name="l00805"></a>00805   <span class="keywordflow">if</span> ( (source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y) &gt; 1.0e-8 )   <span class="comment">// == u^2+v^2 &gt; 0</span>
<a name="l00806"></a>00806   {
<a name="l00807"></a>00807       <span class="comment">// rotZ = 0.5*PI - acos(source_data-&gt;direction.x/sqrt(source_data-&gt;direction.x*source_data-&gt;direction.x + source_data-&gt;direction.y*source_data-&gt;direction.y));</span>
<a name="l00808"></a>00808     <span class="keywordflow">if</span> (source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y &gt;= 0.0f)
<a name="l00809"></a>00809       rotZ = 0.5*PI - acos(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x/sqrt(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y));
<a name="l00810"></a>00810     <span class="keywordflow">else</span>
<a name="l00811"></a>00811       rotZ = 0.5*PI - (-acos(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x/sqrt(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y)));
<a name="l00812"></a>00812         <span class="comment">//rotZ = 2.0*PI - rotZ;   // !!DeBuG!! For negative v, the angle is the complementary! (~negative)</span>
<a name="l00813"></a>00813   }
<a name="l00814"></a>00814   <span class="keywordflow">else</span>
<a name="l00815"></a>00815     rotZ = 0.0;   <span class="comment">// Vector pointing to +Z, do not rotate around Z then.</span>
<a name="l00816"></a>00816  
<a name="l00817"></a>00817   <span class="comment">// -- Set the rotation matrix RzRx (called inverse because moves from the correct position to the reference at +Y):</span>
<a name="l00818"></a>00818   cos_rX = cos(rotX);
<a name="l00819"></a>00819   cos_rZ = cos(rotZ);
<a name="l00820"></a>00820   sin_rX = sin(rotX);
<a name="l00821"></a>00821   sin_rZ = sin(rotZ);
<a name="l00822"></a>00822 
<a name="l00823"></a>00823   <span class="comment">// Rotation matrix RxRz:</span>
<a name="l00824"></a>00824   detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][0] =  cos_rZ;
<a name="l00825"></a>00825   detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][1] = -sin_rZ;
<a name="l00826"></a>00826   detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][2] =  0.0f;
<a name="l00827"></a>00827   detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][3] =  cos_rX*sin_rZ;
<a name="l00828"></a>00828   detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][4] =  cos_rX*cos_rZ;
<a name="l00829"></a>00829   detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][5] = -sin_rX;
<a name="l00830"></a>00830   detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][6] =  sin_rX*sin_rZ;
<a name="l00831"></a>00831   detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][7] =  sin_rX*cos_rZ;
<a name="l00832"></a>00832   detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][8] =  cos_rX;
<a name="l00833"></a>00833     <span class="comment">// printf(" &gt;&gt;&gt; detector_data-&gt;rot_inv: | %.14lf   %.14lf   %.14lf |\n", detector_data-&gt;rot_inv[0], detector_data-&gt;rot_inv[1], detector_data-&gt;rot_inv[2]);</span>
<a name="l00834"></a>00834     <span class="comment">// printf("                             | %.14lf   %.14lf   %.14lf |\n", detector_data-&gt;rot_inv[3], detector_data-&gt;rot_inv[4], detector_data-&gt;rot_inv[5]);</span>
<a name="l00835"></a>00835     <span class="comment">// printf("                             | %.14lf   %.14lf   %.14lf |\n\n", detector_data-&gt;rot_inv[6], detector_data-&gt;rot_inv[7], detector_data-&gt;rot_inv[8]);</span>
<a name="l00836"></a>00836 
<a name="l00837"></a>00837       <span class="comment">/* WRONG rotation: !!DeBuG!!</span>
<a name="l00838"></a>00838 <span class="comment">        // Rotation matrix RzRx:</span>
<a name="l00839"></a>00839 <span class="comment">        detector_data-&gt;rot_inv[0] =  cos_rZ;</span>
<a name="l00840"></a>00840 <span class="comment">        detector_data-&gt;rot_inv[1] = -cos_rX*sin_rZ;</span>
<a name="l00841"></a>00841 <span class="comment">        detector_data-&gt;rot_inv[2] =  sin_rX*sin_rZ;</span>
<a name="l00842"></a>00842 <span class="comment">        detector_data-&gt;rot_inv[3] =  sin_rZ;</span>
<a name="l00843"></a>00843 <span class="comment">        detector_data-&gt;rot_inv[4] =  cos_rX*cos_rZ;</span>
<a name="l00844"></a>00844 <span class="comment">        detector_data-&gt;rot_inv[5] = -sin_rX*cos_rZ;</span>
<a name="l00845"></a>00845 <span class="comment">        detector_data-&gt;rot_inv[6] =  0.0f;</span>
<a name="l00846"></a>00846 <span class="comment">        detector_data-&gt;rot_inv[7] =  sin_rX;</span>
<a name="l00847"></a>00847 <span class="comment">        detector_data-&gt;rot_inv[8] =  cos_rX;</span>
<a name="l00848"></a>00848 <span class="comment">      */</span>
<a name="l00849"></a>00849 
<a name="l00850"></a>00850 
<a name="l00851"></a>00851   <span class="keywordflow">if</span> ((source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y &gt; 0.99990f) &amp;&amp; (*num_projections==1))
<a name="l00852"></a>00852   {
<a name="l00853"></a>00853     <span class="comment">// Simulating a single projection and initial beam pointing to +Y: no rotation needed!!</span>
<a name="l00854"></a>00854     detector_data-&gt;<a class="code" href="structdetector__struct.html#dbe41a01886ae097dac0fa908551d035">rotation_flag</a> = 0;
<a name="l00855"></a>00855     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].x = detector_center.x;
<a name="l00856"></a>00856     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].y = detector_center.y;
<a name="l00857"></a>00857     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].z = detector_center.z;
<a name="l00858"></a>00858 
<a name="l00859"></a>00859     <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       Source pointing to (0,1,0): detector does not rotate and initial location inside the voxels efficiently found.\n"</span>);  <span class="comment">// -&gt; the simulation will be faster than for other angles.");</span>
<a name="l00860"></a>00860 
<a name="l00861"></a>00861   }
<a name="l00862"></a>00862   <span class="keywordflow">else</span>
<a name="l00863"></a>00863   { <span class="comment">// Rotation needed to set the detector perpendicular to +Y:</span>
<a name="l00864"></a>00864     detector_data-&gt;<a class="code" href="structdetector__struct.html#dbe41a01886ae097dac0fa908551d035">rotation_flag</a> = 1;
<a name="l00865"></a>00865     <span class="comment">// -- Rotate the detector center to +Y:</span>
<a name="l00866"></a>00866     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].x = detector_center.x*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][0] + detector_center.y*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][1] + detector_center.z*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][2];
<a name="l00867"></a>00867     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].y = detector_center.x*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][3] + detector_center.y*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][4] + detector_center.z*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][5];
<a name="l00868"></a>00868     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].z = detector_center.x*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][6] + detector_center.y*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][7] + detector_center.z*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[0][8];
<a name="l00869"></a>00869 
<a name="l00870"></a>00870     <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       Rotations from the input direction to +Y [deg]: rotZ = %f , rotX = %f\n"</span>, rotZ*RAD2DEG, rotX*RAD2DEG);
<a name="l00871"></a>00871     
<a name="l00872"></a>00872   }
<a name="l00873"></a>00873   <span class="comment">// -- Set the lower corner (minimum) coordinates at the normalized orientation: +Y. The detector has thickness 0.</span>
<a name="l00874"></a>00874   detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].x = detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].x - 0.5*detector_data-&gt;<a class="code" href="structdetector__struct.html#1f67c512205953e75552865ae7a2490a">width_X</a>;
<a name="l00875"></a>00875   detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].y = detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].y;
<a name="l00876"></a>00876   detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].z = detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[0].z - 0.5*detector_data-&gt;<a class="code" href="structdetector__struct.html#f61592c77c6da548fff31215bf956dd8">height_Z</a>;
<a name="l00877"></a>00877 <span class="comment"></span>
<a name="l00878"></a>00878 <span class="comment">  /////////////////////////////////////////////////////////////////////////////</span>
<a name="l00879"></a>00879 <span class="comment"></span>
<a name="l00880"></a>00880   <span class="comment">// *** Init the fan beam source model:</span>
<a name="l00881"></a>00881 
<a name="l00882"></a>00882   <span class="keywordflow">if</span> (1 == detector_data-&gt;<a class="code" href="structdetector__struct.html#dbe41a01886ae097dac0fa908551d035">rotation_flag</a>)
<a name="l00883"></a>00883   {
<a name="l00884"></a>00884     <span class="comment">// Initial beam NOT pointing to +Y: rotation is needed to move the sampled vector from (0,1,0) to the given direction!!</span>
<a name="l00885"></a>00885     rotX = 0.5*PI - acos(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z);         <span class="comment">// ! Rotation about X: acos(wsrc)==theta, theta=90 for alpha=0, ie, +Y.</span>
<a name="l00886"></a>00886     rotZ = atan2(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y, source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x) - 0.5*PI;   <span class="comment">// ! Rotation about Z:  initial phi = 90 (+Y).  [ATAN2(v,u) = TAN(v/u), with the angle in the correct quadrant.</span>
<a name="l00887"></a>00887     cos_rX = cos(rotX);
<a name="l00888"></a>00888     cos_rZ = cos(rotZ);
<a name="l00889"></a>00889     sin_rX = sin(rotX);
<a name="l00890"></a>00890     sin_rZ = sin(rotZ);
<a name="l00891"></a>00891     <span class="comment">// --Rotation around X (alpha) and then around Z (phi): Rz*Rx (oposite of detector rotation)</span>
<a name="l00892"></a>00892     source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[0][0] =  cos_rZ;
<a name="l00893"></a>00893     source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[0][1] = -cos_rX*sin_rZ;
<a name="l00894"></a>00894     source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[0][2] =  sin_rX*sin_rZ;
<a name="l00895"></a>00895     source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[0][3] =  sin_rZ;
<a name="l00896"></a>00896     source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[0][4] =  cos_rX*cos_rZ;
<a name="l00897"></a>00897     source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[0][5] = -sin_rX*cos_rZ;
<a name="l00898"></a>00898     source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[0][6] =  0.0f;
<a name="l00899"></a>00899     source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[0][7] =  sin_rX;
<a name="l00900"></a>00900     source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[0][8] =  cos_rX;
<a name="l00901"></a>00901     
<a name="l00902"></a>00902     <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       Rotations from +Y to the input direction for the fan beam source model [deg]: rotZ = %f , rotX = %f\n"</span>, rotZ*RAD2DEG, rotX*RAD2DEG);
<a name="l00903"></a>00903   }      
<a name="l00904"></a>00904 <span class="comment"></span>
<a name="l00905"></a>00905 <span class="comment">  /////////////////////////////////////////////////////////////////////////////</span>
<a name="l00906"></a>00906 <span class="comment"></span>
<a name="l00907"></a>00907   <span class="comment">// *** Allocate array for the 4 detected images (non-scattered, Compton, Rayleigh, multiple-scatter):</span>
<a name="l00908"></a>00908   *image_bytes = 4 * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)*(detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x)*(detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y);
<a name="l00909"></a>00909   (*image_ptr) = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>*) malloc(*image_bytes);
<a name="l00910"></a>00910   <span class="keywordflow">if</span> (*image_ptr==NULL)
<a name="l00911"></a>00911   {
<a name="l00912"></a>00912     printf(<span class="stringliteral">"\n\n   !!malloc ERROR!! Not enough memory to allocate %d pixels for the 4 scatter images (%f Mbytes)!!\n\n"</span>, ((detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x)*(detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y)), (*image_bytes)/(1024.f*1024.f));
<a name="l00913"></a>00913     exit(-2);
<a name="l00914"></a>00914   }
<a name="l00915"></a>00915   <span class="keywordflow">else</span>
<a name="l00916"></a>00916   {
<a name="l00917"></a>00917     <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       Array for 4 scatter images correctly allocated (%f Mbytes)\n"</span>, (*image_bytes)/(1024.f*1024.f));
<a name="l00918"></a>00918   }
<a name="l00919"></a>00919 
<a name="l00920"></a>00920   <span class="comment">// *** Initialize the images to 0 in the CPU.</span>
<a name="l00921"></a>00921   <span class="keyword">register</span> <span class="keywordtype">int</span> j, pixels_per_image = (detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x * detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y);
<a name="l00922"></a>00922   <span class="keywordflow">for</span> (j=0; j&lt;pixels_per_image; j++)
<a name="l00923"></a>00923   {
<a name="l00924"></a>00924     (*image_ptr)[j                   ] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);   <span class="comment">// Initialize non-scattered image</span>
<a name="l00925"></a>00925     (*image_ptr)[j+  pixels_per_image] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);   <span class="comment">// Initialize Compton image</span>
<a name="l00926"></a>00926     (*image_ptr)[j+2*pixels_per_image] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);   <span class="comment">// Initialize Rayleigh image</span>
<a name="l00927"></a>00927     (*image_ptr)[j+3*pixels_per_image] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);   <span class="comment">// Initialize multiple scattering image</span>
<a name="l00928"></a>00928   }
<a name="l00929"></a>00929 }
<a name="l00930"></a>00930 
<a name="l00931"></a>00931 
<a name="l00932"></a>00932 <span class="comment"></span>
<a name="l00933"></a>00933 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00934"></a>00934 <span class="comment">//! Extract a file name from an input text line, trimming the initial blanks,</span>
<a name="l00935"></a>00935 <span class="comment">//! trailing comment (#) and stopping at the first blank (the file name should</span>
<a name="l00936"></a>00936 <span class="comment">//! not contain blanks).</span>
<a name="l00937"></a>00937 <span class="comment">//!</span>
<a name="l00938"></a>00938 <span class="comment">//!       @param[in] input_line   Input sentence with blanks and a trailing comment</span>
<a name="l00939"></a>00939 <span class="comment">//!       @param[out] file_name   Trimmed file name</span>
<a name="l00940"></a>00940 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00941"></a><a class="code" href="MC-GPU__v1_81_8h.html#96dba25b308814b25fbae71e27617f12">00941</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="MC-GPU__v1_81_8cu.html#96dba25b308814b25fbae71e27617f12" title="Extract a file name from an input text line, trimming the initial blanks, trailing...">trim_name</a>(<span class="keywordtype">char</span>* input_line, <span class="keywordtype">char</span>* file_name)
<a name="l00942"></a>00942 {
<a name="l00943"></a>00943   <span class="keywordtype">int</span> a=0, b=0;
<a name="l00944"></a>00944   
<a name="l00945"></a>00945   <span class="comment">// Discard initial blanks:</span>
<a name="l00946"></a>00946   <span class="keywordflow">while</span>(<span class="charliteral">' '</span>==input_line[a])
<a name="l00947"></a>00947   {
<a name="l00948"></a>00948     a++;
<a name="l00949"></a>00949   }
<a name="l00950"></a>00950 
<a name="l00951"></a>00951   <span class="comment">// Read file name until a blank or a comment symbol (#) is found:</span>
<a name="l00952"></a>00952   <span class="keywordflow">while</span> ((<span class="charliteral">' '</span>!=input_line[a])&amp;&amp;(<span class="charliteral">'#'</span>!=input_line[a]))
<a name="l00953"></a>00953   {
<a name="l00954"></a>00954     file_name[b] = input_line[a];
<a name="l00955"></a>00955     b++;
<a name="l00956"></a>00956     a++;
<a name="l00957"></a>00957   }
<a name="l00958"></a>00958   
<a name="l00959"></a>00959   file_name[b] = <span class="charliteral">'\0'</span>;    <span class="comment">// Terminate output string</span>
<a name="l00960"></a>00960 }
<a name="l00961"></a>00961 <span class="comment"></span>
<a name="l00962"></a>00962 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00963"></a>00963 <span class="comment">//! Read a line of text and trim initial blancks and trailing comments (#).</span>
<a name="l00964"></a>00964 <span class="comment">//!</span>
<a name="l00965"></a>00965 <span class="comment">//!       @param[in] num   Characters to read</span>
<a name="l00966"></a>00966 <span class="comment">//!       @param[in] file_ptr   Pointer to the input file stream</span>
<a name="l00967"></a>00967 <span class="comment">//!       @param[out] trimmed_line   Trimmed line from input file, skipping empty lines and comments</span>
<a name="l00968"></a>00968 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00969"></a><a class="code" href="MC-GPU__v1_81_8h.html#ea168bca1466813e03b649931a4f670f">00969</a> <span class="comment"></span><span class="keywordtype">char</span>* <a class="code" href="MC-GPU__v1_81_8cu.html#ea168bca1466813e03b649931a4f670f" title="Read a line of text and trim initial blancks and trailing comments (#).">fgets_trimmed</a>(<span class="keywordtype">char</span>* trimmed_line, <span class="keywordtype">int</span> num, FILE* file_ptr)
<a name="l00970"></a>00970 {
<a name="l00971"></a>00971   <span class="keywordtype">char</span>  new_line[250];
<a name="l00972"></a>00972   <span class="keywordtype">char</span> *new_line_ptr = NULL;
<a name="l00973"></a>00973   <span class="keywordtype">int</span> a=0, b=0;
<a name="l00974"></a>00974   trimmed_line[0] = <span class="charliteral">'\0'</span>;   <span class="comment">//  Init with a mark that means no file input</span>
<a name="l00975"></a>00975   
<a name="l00976"></a>00976   <span class="keywordflow">do</span>
<a name="l00977"></a>00977   {
<a name="l00978"></a>00978     a=0; b=0;
<a name="l00979"></a>00979     new_line_ptr = fgets(new_line, num, file_ptr);   <span class="comment">// Read new line</span>
<a name="l00980"></a>00980     <span class="keywordflow">if</span> (new_line_ptr != NULL)
<a name="l00981"></a>00981     {
<a name="l00982"></a>00982       <span class="comment">// Discard initial blanks:</span>
<a name="l00983"></a>00983       <span class="keywordflow">while</span>(<span class="charliteral">' '</span>==new_line[a])
<a name="l00984"></a>00984       {
<a name="l00985"></a>00985         a++;
<a name="l00986"></a>00986       }
<a name="l00987"></a>00987       <span class="comment">// Read file until a comment symbol (#) or end-of-line are found:</span>
<a name="l00988"></a>00988       <span class="keywordflow">while</span> ((<span class="charliteral">'\n'</span>!=new_line[a])&amp;&amp;(<span class="charliteral">'#'</span>!=new_line[a]))
<a name="l00989"></a>00989       {
<a name="l00990"></a>00990         trimmed_line[b] = new_line[a];
<a name="l00991"></a>00991         b++;
<a name="l00992"></a>00992         a++;
<a name="l00993"></a>00993       }
<a name="l00994"></a>00994     }
<a name="l00995"></a>00995   } <span class="keywordflow">while</span>(new_line_ptr!=NULL &amp;&amp;  <span class="charliteral">'\0'</span>==trimmed_line[0]);   <span class="comment">// Keep reading lines until end-of-file or a line that is not empty or only comment is found</span>
<a name="l00996"></a>00996   
<a name="l00997"></a>00997   trimmed_line[b] = <span class="charliteral">'\0'</span>;    <span class="comment">// Terminate output string</span>
<a name="l00998"></a>00998   <span class="keywordflow">return</span> new_line_ptr;
<a name="l00999"></a>00999 }
<a name="l01000"></a>01000 
<a name="l01001"></a>01001 
<a name="l01002"></a>01002 <span class="comment"></span>
<a name="l01003"></a>01003 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01004"></a>01004 <span class="comment">//! Read the voxel data and allocate the material and density matrix.</span>
<a name="l01005"></a>01005 <span class="comment">//! Also find and report the maximum density defined in the geometry.</span>
<a name="l01006"></a>01006 <span class="comment">//!</span>
<a name="l01007"></a>01007 <span class="comment"></span><span class="comment">// -- Sample voxel geometry file:</span>
<a name="l01008"></a>01008 <span class="comment">//</span>
<a name="l01009"></a>01009 <span class="comment">//   #  (comment lines...)</span>
<a name="l01010"></a>01010 <span class="comment">//   #</span>
<a name="l01011"></a>01011 <span class="comment">//   #   Voxel order: X runs first, then Y, then Z.</span>
<a name="l01012"></a>01012 <span class="comment">//   #</span>
<a name="l01013"></a>01013 <span class="comment">//   [SECTION VOXELS HEADER v.2008-04-13]</span>
<a name="l01014"></a>01014 <span class="comment">//   411  190  113      No. OF VOXELS IN X,Y,Z</span>
<a name="l01015"></a>01015 <span class="comment">//   5.000e-02  5.000e-02  5.000e-02    VOXEL SIZE (cm) ALONG X,Y,Z</span>
<a name="l01016"></a>01016 <span class="comment">//   1                  COLUMN NUMBER WHERE MATERIAL ID IS LOCATED</span>
<a name="l01017"></a>01017 <span class="comment">//   2                  COLUMN NUMBER WHERE THE MASS DENSITY IS LOCATED</span>
<a name="l01018"></a>01018 <span class="comment">//   1                  BLANK LINES AT END OF X,Y-CYCLES (1=YES,0=NO)</span>
<a name="l01019"></a>01019 <span class="comment">//   [END OF VXH SECTION]</span>
<a name="l01020"></a>01020 <span class="comment">//   1 0.00120479</span>
<a name="l01021"></a>01021 <span class="comment">//   1 0.00120479</span>
<a name="l01022"></a>01022 <span class="comment">//   ...</span>
<a name="l01023"></a>01023 <span class="comment">//</span><span class="comment"></span>
<a name="l01024"></a>01024 <span class="comment">//!       @param[in] file_name_voxels  Name of the voxelized geometry file.</span>
<a name="l01025"></a>01025 <span class="comment">//!       @param[out] density_max  Array with the maximum density for each material in the voxels.</span>
<a name="l01026"></a>01026 <span class="comment">//!       @param[out] voxel_data   Pointer to a structure containing the voxel number and size.</span>
<a name="l01027"></a>01027 <span class="comment">//!       @param[out] voxel_mat_dens_ptr   Pointer to the vector with the voxel materials and densities.</span>
<a name="l01028"></a>01028 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01029"></a><a class="code" href="MC-GPU__v1_81_8h.html#1daa1f1df034e2ed743ee7012e427222">01029</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="MC-GPU__v1_81_8cu.html#1daa1f1df034e2ed743ee7012e427222" title="Read the voxel data and allocate the material and density matrix.">load_voxels</a>(<span class="keywordtype">int</span> myID, <span class="keywordtype">char</span>* file_name_voxels, <span class="keywordtype">float</span>* density_max, <span class="keyword">struct</span> <a class="code" href="structvoxel__struct.html" title="Structure defining a voxelized box with the back-lower corner at the coordinate origin...">voxel_struct</a>* voxel_data, float2** voxel_mat_dens_ptr, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* voxel_mat_dens_bytes)
<a name="l01030"></a>01030 {
<a name="l01031"></a>01031   <span class="keywordtype">char</span> new_line[250];
<a name="l01032"></a>01032   <span class="keywordtype">char</span> *new_line_ptr = NULL;
<a name="l01033"></a>01033   
<a name="l01034"></a>01034   FILE* file_ptr = fopen(file_name_voxels, <span class="stringliteral">"r"</span>);
<a name="l01035"></a>01035   <span class="keywordflow">if</span> (file_ptr==NULL)
<a name="l01036"></a>01036   {
<a name="l01037"></a>01037     printf(<span class="stringliteral">"\n\n   !!fopen ERROR!! File %s does not exist!!\n"</span>, file_name_voxels);
<a name="l01038"></a>01038     exit(-2);
<a name="l01039"></a>01039   }
<a name="l01040"></a>01040   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n    -- Reading voxel file \'%s\':\n"</span>,file_name_voxels);
<a name="l01041"></a>01041   <span class="keywordflow">do</span>
<a name="l01042"></a>01042   {
<a name="l01043"></a>01043     new_line_ptr = fgets(new_line, 250, file_ptr);
<a name="l01044"></a>01044     <span class="keywordflow">if</span> (new_line_ptr==NULL)
<a name="l01045"></a>01045     {
<a name="l01046"></a>01046       printf(<span class="stringliteral">"\n\n   !!Reading ERROR!! File is not readable or does not contain the string \'[SECTION VOXELS HEADER\'!!\n"</span>);
<a name="l01047"></a>01047       exit(-2);
<a name="l01048"></a>01048     }
<a name="l01049"></a>01049   }
<a name="l01050"></a>01050   <span class="keywordflow">while</span>(strstr(new_line,<span class="stringliteral">"[SECTION VOXELS"</span>)==NULL);   <span class="comment">// Skip comments and empty lines until the header begins</span>
<a name="l01051"></a>01051 
<a name="l01052"></a>01052   fgets(new_line, 250, file_ptr);   <span class="comment">// Read full line (max. 250 characters).</span>
<a name="l01053"></a>01053   sscanf(new_line, <span class="stringliteral">"%d %d %d"</span>,&amp;voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.x, &amp;voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.y, &amp;voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.z);
<a name="l01054"></a>01054   fgets(new_line, 250, file_ptr);
<a name="l01055"></a>01055   sscanf(new_line, <span class="stringliteral">"%f %f %f"</span>, &amp;voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.x, &amp;voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.y, &amp;voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.z);
<a name="l01056"></a>01056   <span class="keywordflow">do</span>
<a name="l01057"></a>01057   {
<a name="l01058"></a>01058     new_line_ptr = fgets(new_line, 250, file_ptr);
<a name="l01059"></a>01059     <span class="keywordflow">if</span> (new_line_ptr==NULL)
<a name="l01060"></a>01060     {
<a name="l01061"></a>01061       printf(<span class="stringliteral">"\n\n   !!Reading ERROR!! File is not readable or does not contain the string \'[END OF VXH SECTION]\'!!\n"</span>);
<a name="l01062"></a>01062       exit(-2);
<a name="l01063"></a>01063     }
<a name="l01064"></a>01064   }
<a name="l01065"></a>01065   <span class="keywordflow">while</span>(strstr(new_line,<span class="stringliteral">"[END OF VXH SECTION"</span>)==NULL);   <span class="comment">// Skip rest of the header</span>
<a name="l01066"></a>01066 
<a name="l01067"></a>01067   <span class="comment">// -- Store the size of the voxel bounding box (used in the source function):</span>
<a name="l01068"></a>01068   voxel_data-&gt;<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.x = voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.x * voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.x;
<a name="l01069"></a>01069   voxel_data-&gt;<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.y = voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.y * voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.y;
<a name="l01070"></a>01070   voxel_data-&gt;<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.z = voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.z * voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.z;
<a name="l01071"></a>01071 
<a name="l01072"></a>01072   
<a name="l01073"></a>01073   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       Number of voxels in the input geometry file: %d x %d x %d =  %d\n"</span>, voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.x, voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.y, voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.z, (voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.x*voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.y*voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.z));
<a name="l01074"></a>01074   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       Size of the input voxels: %f x %f x %f cm\n"</span>, voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.x, voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.y, voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.z);
<a name="l01075"></a>01075   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       Voxel bounding box size: %f x %f x %f cm\n"</span>, voxel_data-&gt;<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.x, voxel_data-&gt;<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.y,  voxel_data-&gt;<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.z);
<a name="l01076"></a>01076   <span class="comment">// printf("       The geometry must be given in two columns, with the voxel density in the second column.\n");</span>
<a name="l01077"></a>01077   <span class="comment">// printf("       The  X,Y-cycles may, or may not, be separated by blank lines.\n");</span>
<a name="l01078"></a>01078 
<a name="l01079"></a>01079   
<a name="l01080"></a>01080   <span class="comment">// -- Store the inverse of the pixel sides (in cm) to speed up the particle location in voxels.</span>
<a name="l01081"></a>01081   voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.x = 1.0f/(voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.x);
<a name="l01082"></a>01082   voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.y = 1.0f/(voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.y);
<a name="l01083"></a>01083   voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.z = 1.0f/(voxel_data-&gt;<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.z);
<a name="l01084"></a>01084 
<a name="l01085"></a>01085   <span class="comment">// -- Allocate the voxel matrix and store array size:</span>
<a name="l01086"></a>01086   *voxel_mat_dens_bytes = <span class="keyword">sizeof</span>(float2)*(voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.x)*(voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.y)*(voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.z);
<a name="l01087"></a>01087   *voxel_mat_dens_ptr    = (float2*) malloc(*voxel_mat_dens_bytes);
<a name="l01088"></a>01088   <span class="keywordflow">if</span> (*voxel_mat_dens_ptr==NULL)
<a name="l01089"></a>01089   {
<a name="l01090"></a>01090     printf(<span class="stringliteral">"\n\n   !!malloc ERROR!! Not enough memory to allocate %d voxels (%f Mbytes)!!\n\n"</span>, (voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.x*voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.y*voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.z), (*voxel_mat_dens_bytes)/(1024.f*1024.f));
<a name="l01091"></a>01091     exit(-2);
<a name="l01092"></a>01092   }
<a name="l01093"></a>01093   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n    -- Initializing the voxel material and density vector (%f Mbytes)\n"</span>, (*voxel_mat_dens_bytes)/(1024.f*1024.f));
<a name="l01094"></a>01094 
<a name="l01095"></a>01095   <span class="comment">// -- Read the voxel densities:</span>
<a name="l01096"></a>01096   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       Reading the voxel densities... "</span>);
<a name="l01097"></a>01097       
<a name="l01098"></a>01098   <span class="keywordtype">int</span> i, j, k, read_lines=0, dummy_material;
<a name="l01099"></a>01099   <span class="keywordtype">float</span> dummy_density;
<a name="l01100"></a>01100   float2 *voxels_ptr = *voxel_mat_dens_ptr;
<a name="l01101"></a>01101 
<a name="l01102"></a>01102   <span class="keywordflow">for</span> (k=0; k&lt;<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>; k++)
<a name="l01103"></a>01103     density_max[k] = -999.0f;   <span class="comment">// Init array with an impossible low density value</span>
<a name="l01104"></a>01104   
<a name="l01105"></a>01105 
<a name="l01106"></a>01106   <span class="keywordflow">for</span>(k=0; k&lt;(voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.z); k++)
<a name="l01107"></a>01107   {
<a name="l01108"></a>01108     <span class="keywordflow">for</span>(j=0; j&lt;(voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.y); j++)
<a name="l01109"></a>01109     {
<a name="l01110"></a>01110       <span class="keywordflow">for</span>(i=0; i&lt;(voxel_data-&gt;<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.x); i++)
<a name="l01111"></a>01111       {
<a name="l01112"></a>01112         fscanf(file_ptr,<span class="stringliteral">"%d %f"</span>, &amp;dummy_material, &amp;dummy_density);  <span class="comment">// Read the next 2 numbers</span>
<a name="l01113"></a>01113         fgets(new_line, 250, file_ptr);                             <span class="comment">// Continue reading until end-of-line</span>
<a name="l01114"></a>01114 
<a name="l01115"></a>01115         <span class="keywordflow">if</span> (dummy_material&gt;MAX_MATERIALS)
<a name="l01116"></a>01116         {
<a name="l01117"></a>01117           printf(<span class="stringliteral">"\n\n   !!ERROR!! Voxel material number too high: #mat=%d, MAX_MATERIALS=%d\n\n"</span>, dummy_material, MAX_MATERIALS);
<a name="l01118"></a>01118           exit(-2);
<a name="l01119"></a>01119         }
<a name="l01120"></a>01120         
<a name="l01121"></a>01121         <span class="keywordflow">if</span> (dummy_density &gt; density_max[dummy_material-1])
<a name="l01122"></a>01122           density_max[dummy_material-1] = dummy_density;  <span class="comment">// Store maximum density for each material</span>
<a name="l01123"></a>01123 
<a name="l01124"></a>01124         (*voxels_ptr).x = (float)(dummy_material)+0.0001f;  <span class="comment">// Assign material value as float (the integer value will be recovered by truncation)</span>
<a name="l01125"></a>01125         (*voxels_ptr).y = dummy_density;      <span class="comment">// Assign density value</span>
<a name="l01126"></a>01126         voxels_ptr++;                         <span class="comment">// Move to next voxel</span>
<a name="l01127"></a>01127 
<a name="l01128"></a>01128         read_lines++;
<a name="l01129"></a>01129       }
<a name="l01130"></a>01130     }
<a name="l01131"></a>01131   }
<a name="l01132"></a>01132   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"Total number of voxels read: %d\n"</span>,read_lines);
<a name="l01133"></a>01133   fclose(file_ptr);     <span class="comment">// Close input file</span>
<a name="l01134"></a>01134 }
<a name="l01135"></a>01135 
<a name="l01136"></a>01136 <span class="comment"></span>
<a name="l01137"></a>01137 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01138"></a>01138 <span class="comment">//! Read the material input files and set the mean free paths and the "linear_interp" structures.</span>
<a name="l01139"></a>01139 <span class="comment">//! Find the material nominal density. Set the Woodcock trick data.</span>
<a name="l01140"></a>01140 <span class="comment"></span><span class="comment">//</span>
<a name="l01141"></a>01141 <span class="comment">// -- Sample material data file (data obtained from the PENELOPE 2006 database and models):</span>
<a name="l01142"></a>01142 <span class="comment">//</span>
<a name="l01143"></a>01143 <span class="comment">//    [MATERIAL NAME]</span>
<a name="l01144"></a>01144 <span class="comment">//     Water</span>
<a name="l01145"></a>01145 <span class="comment">//    [NOMINAL DENSITY (g/cm^3)]</span>
<a name="l01146"></a>01146 <span class="comment">//     1.000</span>
<a name="l01147"></a>01147 <span class="comment">//    [NUMBER OF DATA VALUES]</span>
<a name="l01148"></a>01148 <span class="comment">//     4096</span>
<a name="l01149"></a>01149 <span class="comment">//    [MEAN FREE PATHS :: Energy (eV) || Rayleigh | Compton | Photoelectric | Pair-production | TOTAL (cm)]</span>
<a name="l01150"></a>01150 <span class="comment">//     1.00000E+03  7.27451E-01  9.43363E+01  2.45451E-04  1.00000E+35  2.45367E-04</span>
<a name="l01151"></a>01151 <span class="comment">//     5.00000E+03  1.80004E+00  8.35996E+00  2.38881E-02  1.00000E+35  2.35089E-02</span>
<a name="l01152"></a>01152 <span class="comment">//     1.00000E+04  4.34941E+00  6.26746E+00  2.02568E-01  1.00000E+35  1.87755E-01</span>
<a name="l01153"></a>01153 <span class="comment">//     ...</span>
<a name="l01154"></a>01154 <span class="comment">//     #[RAYLEIGH INTERACTIONS (RITA sampling  of atomic form factor from EPDL database)]</span>
<a name="l01155"></a>01155 <span class="comment">//     ...</span>
<a name="l01156"></a>01156 <span class="comment">//     #[COMPTON INTERACTIONS (relativistic impulse model with approximated one-electron analytical profiles)]</span>
<a name="l01157"></a>01157 <span class="comment">//     ...</span>
<a name="l01158"></a>01158 <span class="comment">//</span><span class="comment"></span>
<a name="l01159"></a>01159 <span class="comment">//!       @param[in] file_name_materials    Array with the names of the material files.</span>
<a name="l01160"></a>01160 <span class="comment">//!       @param[in] density_max   maximum density in the geometry (needed to set Woodcock trick)</span>
<a name="l01161"></a>01161 <span class="comment">//!       @param[out] density_nominal   Array with the nominal density of the materials read</span>
<a name="l01162"></a>01162 <span class="comment">//!       @param[out] mfp_table_data   Constant values for the linear interpolation</span>
<a name="l01163"></a>01163 <span class="comment">//!       @param[out] mfp_table_a_ptr   First element for the linear interpolation.</span>
<a name="l01164"></a>01164 <span class="comment">//!       @param[out] mfp_table_b_ptr   Second element for the linear interpolation.</span>
<a name="l01165"></a>01165 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01166"></a><a class="code" href="MC-GPU__v1_81_8h.html#d23b50cb34b4aadcd24d9fec7e47ad24">01166</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="MC-GPU__v1_81_8cu.html#55f3171a6cdb59fc43e65aa19c676d80" title="Read the material input files and set the mean free paths and the &amp;quot;linear_interp&amp;quot;...">load_material</a>(<span class="keywordtype">int</span> myID, <span class="keywordtype">char</span> file_name_materials[<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>][250], <span class="keywordtype">float</span>* density_max, <span class="keywordtype">float</span>* density_nominal, <span class="keyword">struct</span> <a class="code" href="structlinear__interp.html" title="Structure with the basic data required by the linear interpolation of the mean free...">linear_interp</a>* mfp_table_data, float2** mfp_Woodcock_table_ptr, <span class="keywordtype">int</span>* mfp_Woodcock_table_bytes, float3** mfp_table_a_ptr, float3** mfp_table_b_ptr, <span class="keywordtype">int</span>* mfp_table_bytes, <span class="keyword">struct</span> <a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a> *rayleigh_table_ptr, <span class="keyword">struct</span> <a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a> *compton_table_ptr)
<a name="l01167"></a>01167 {
<a name="l01168"></a>01168   <span class="keywordtype">char</span> new_line[250];
<a name="l01169"></a>01169   <span class="keywordtype">char</span> *new_line_ptr = NULL;
<a name="l01170"></a>01170   <span class="keywordtype">int</span> mat, i, bin, input_num_values = 0, input_rayleigh_values = 0, input_num_shells = 0;
<a name="l01171"></a>01171   <span class="keywordtype">double</span> delta_e=-99999.0;
<a name="l01172"></a>01172 
<a name="l01173"></a>01173   <span class="comment">// -- Init the number of shells to 0 for all materials</span>
<a name="l01174"></a>01174   <span class="keywordflow">for</span> (mat=0; mat&lt;MAX_MATERIALS; mat++)
<a name="l01175"></a>01175     compton_table_ptr-&gt;<a class="code" href="structcompton__struct.html#ef81eb007c90d13552ea867912f0d2c3">noscco</a>[mat] = 0;
<a name="l01176"></a>01176     
<a name="l01177"></a>01177           
<a name="l01178"></a>01178   <span class="comment">// --Read the material data files:</span>
<a name="l01179"></a>01179   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n    -- Reading the material data files (MAX_MATERIALS=%d):\n"</span>, MAX_MATERIALS);
<a name="l01180"></a>01180   <span class="keywordflow">for</span> (mat=0; mat&lt;MAX_MATERIALS; mat++)
<a name="l01181"></a>01181   {
<a name="l01182"></a>01182     <span class="keywordflow">if</span> ((file_name_materials[mat][0]==<span class="charliteral">'\0'</span>) || (file_name_materials[mat][0]==<span class="charliteral">'\n'</span>) || (density_max[mat]&lt;0))  <span class="comment">//  Empty file name, or material not found in the voxels</span>
<a name="l01183"></a>01183        <span class="keywordflow">continue</span>;   <span class="comment">// Re-start loop for next material</span>
<a name="l01184"></a>01184 
<a name="l01185"></a>01185     <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"         Mat %d: File \'%s\'\n"</span>, mat, file_name_materials[mat]);
<a name="l01186"></a>01186 <span class="comment">//     printf("    -- Reading material file #%d: \'%s\'\n", mat, file_name_materials[mat]);</span>
<a name="l01187"></a>01187 
<a name="l01188"></a>01188     FILE* file_ptr = fopen(file_name_materials[mat], <span class="stringliteral">"r"</span>);
<a name="l01189"></a>01189     <span class="keywordflow">if</span> (file_ptr==NULL)
<a name="l01190"></a>01190     {
<a name="l01191"></a>01191       printf(<span class="stringliteral">"\n\n   !!fopen ERROR!! File %d \'%s\' does not exist!!\n"</span>, mat, file_name_materials[mat]);
<a name="l01192"></a>01192       exit(-2);
<a name="l01193"></a>01193     }
<a name="l01194"></a>01194     <span class="keywordflow">do</span>
<a name="l01195"></a>01195     {
<a name="l01196"></a>01196       new_line_ptr = fgets(new_line, 250, file_ptr);   <span class="comment">// Read full line (max. 250 characters).</span>
<a name="l01197"></a>01197       <span class="keywordflow">if</span> (new_line_ptr==NULL)
<a name="l01198"></a>01198       {
<a name="l01199"></a>01199         printf(<span class="stringliteral">"\n\n   !!Reading ERROR!! File is not readable or does not contain the string \'[NOMINAL DENSITY\'!!\n"</span>);
<a name="l01200"></a>01200         exit(-2);
<a name="l01201"></a>01201       }
<a name="l01202"></a>01202     }
<a name="l01203"></a>01203     <span class="keywordflow">while</span>(strstr(new_line,<span class="stringliteral">"[NOMINAL DENSITY"</span>)==NULL);   <span class="comment">// Skip rest of the header</span>
<a name="l01204"></a>01204 
<a name="l01205"></a>01205     <span class="comment">// Read the material nominal density:</span>
<a name="l01206"></a>01206     fgets(new_line, 250, file_ptr);
<a name="l01207"></a>01207     sscanf(new_line, <span class="stringliteral">"# %f"</span>, &amp;density_nominal[mat]);
<a name="l01208"></a>01208     <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"                Nominal density = %f g/cm^3; Max mat density in voxels = %f\n"</span>, density_nominal[mat], density_max[mat]);
<a name="l01209"></a>01209 
<a name="l01210"></a>01210     <span class="comment">// --For the first material, set the number of energy values and allocate table arrays:</span>
<a name="l01211"></a>01211     fgets(new_line, 250, file_ptr);
<a name="l01212"></a>01212     fgets(new_line, 250, file_ptr);
<a name="l01213"></a>01213     sscanf(new_line, <span class="stringliteral">"# %d"</span>, &amp;input_num_values);
<a name="l01214"></a>01214     <span class="keywordflow">if</span> (0==mat)
<a name="l01215"></a>01215     {
<a name="l01216"></a>01216       mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#2bea2f84374be1b9afd5d896b16a7a46">num_values</a> = input_num_values;
<a name="l01217"></a>01217       <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"                Number of energy values in the mean free path database: %d.\n"</span>, input_num_values);
<a name="l01218"></a>01218 
<a name="l01219"></a>01219       <span class="comment">// Allocate memory for the linear interpolation arrays:</span>
<a name="l01220"></a>01220       *mfp_Woodcock_table_bytes = <span class="keyword">sizeof</span>(float2)*input_num_values;
<a name="l01221"></a>01221       *mfp_Woodcock_table_ptr   = (float2*) malloc(*mfp_Woodcock_table_bytes);  <span class="comment">// Allocate space for the 2 parameter table</span>
<a name="l01222"></a>01222       *mfp_table_bytes = <span class="keyword">sizeof</span>(float3)*input_num_values*MAX_MATERIALS;
<a name="l01223"></a>01223       *mfp_table_a_ptr = (float3*) malloc(*mfp_table_bytes);  <span class="comment">// Allocate space for the 4 MFP tables</span>
<a name="l01224"></a>01224       *mfp_table_b_ptr = (float3*) malloc(*mfp_table_bytes);
<a name="l01225"></a>01225       *mfp_table_bytes = <span class="keyword">sizeof</span>(float3)*input_num_values*MAX_MATERIALS;
<a name="l01226"></a>01226 
<a name="l01227"></a>01227       <span class="keywordflow">if</span> (input_num_values&gt;MAX_ENERGYBINS)
<a name="l01228"></a>01228       {
<a name="l01229"></a>01229         printf(<span class="stringliteral">"\n\n   !!load_material ERROR!! Too many energy bins (Input bins=%d): increase parameter MAX_ENERGYBINS=%d!!\n\n"</span>, input_num_values, MAX_ENERGYBINS);
<a name="l01230"></a>01230         exit(-2);
<a name="l01231"></a>01231       }
<a name="l01232"></a>01232       
<a name="l01233"></a>01233       <span class="keywordflow">if</span> ((NULL==*mfp_Woodcock_table_ptr)||(NULL==*mfp_table_a_ptr)||(NULL==*mfp_table_b_ptr))
<a name="l01234"></a>01234       {
<a name="l01235"></a>01235         printf(<span class="stringliteral">"\n\n   !!malloc ERROR!! Not enough memory to allocate the linear interpolation data: %d bytes!!\n\n"</span>, (*mfp_Woodcock_table_bytes+2*(*mfp_table_bytes)));
<a name="l01236"></a>01236         exit(-2);
<a name="l01237"></a>01237       }
<a name="l01238"></a>01238       <span class="keywordflow">else</span>
<a name="l01239"></a>01239       {
<a name="l01240"></a>01240         <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"                Linear interpolation data correctly allocated (%f Mbytes)\n"</span>, (*mfp_Woodcock_table_bytes+2*(*mfp_table_bytes))/(1024.f*1024.f));
<a name="l01241"></a>01241       }
<a name="l01242"></a>01242       <span class="keywordflow">for</span> (i=0; i&lt;input_num_values; i++)
<a name="l01243"></a>01243       {
<a name="l01244"></a>01244         (*mfp_Woodcock_table_ptr)[i].x = 99999999.99f;    <span class="comment">// Init this array with a huge MFP, the minimum values are calculated below</span>
<a name="l01245"></a>01245       }
<a name="l01246"></a>01246     }
<a name="l01247"></a>01247     <span class="keywordflow">else</span>   <span class="comment">// Materials after first</span>
<a name="l01248"></a>01248     {
<a name="l01249"></a>01249       <span class="keywordflow">if</span> (input_num_values != mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#2bea2f84374be1b9afd5d896b16a7a46">num_values</a>)
<a name="l01250"></a>01250       {
<a name="l01251"></a>01251         printf(<span class="stringliteral">"\n\n   !!load_material ERROR!! Incorrect number of energy values given in material \'%s\': input=%d, expected=%d\n"</span>,file_name_materials[mat], input_num_values, mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#2bea2f84374be1b9afd5d896b16a7a46">num_values</a>);
<a name="l01252"></a>01252         exit(-2);
<a name="l01253"></a>01253       }
<a name="l01254"></a>01254     }
<a name="l01255"></a>01255 
<a name="l01256"></a>01256     <span class="comment">// -- Read the mean free paths (and Rayleigh cumulative prob):</span>
<a name="l01257"></a>01257     fgets(new_line, 250, file_ptr);
<a name="l01258"></a>01258     fgets(new_line, 250, file_ptr);
<a name="l01259"></a>01259     <span class="keywordtype">double</span> d_energy, d_rayleigh, d_compton, d_photelectric, d_total_mfp, d_pmax, e_last=-1.0;
<a name="l01260"></a>01260     
<a name="l01261"></a>01261     <span class="keywordflow">for</span> (i=0; i&lt;input_num_values; i++)
<a name="l01262"></a>01262     {
<a name="l01263"></a>01263 
<a name="l01264"></a>01264       fgets(new_line, 250, file_ptr);
<a name="l01265"></a>01265       sscanf(new_line,<span class="stringliteral">"  %le  %le  %le  %le  %le  %le"</span>, &amp;d_energy, &amp;d_rayleigh, &amp;d_compton, &amp;d_photelectric, &amp;d_total_mfp, &amp;d_pmax);
<a name="l01266"></a>01266 
<a name="l01267"></a>01267       <span class="comment">// Find and store the minimum total MFP at the current energy, for every material's maximum density:</span>
<a name="l01268"></a>01268       <span class="keywordtype">float</span> temp_mfp = d_total_mfp*(density_nominal[mat])/(density_max[mat]);
<a name="l01269"></a>01269       <span class="keywordflow">if</span> (temp_mfp &lt; (*mfp_Woodcock_table_ptr)[i].x)
<a name="l01270"></a>01270         (*mfp_Woodcock_table_ptr)[i].x = temp_mfp;       <span class="comment">// Store minimum total mfp [cm]</span>
<a name="l01271"></a>01271 
<a name="l01272"></a>01272       <span class="comment">// Store the inverse MFP data points with [num_values rows]*[MAX_MATERIALS columns]</span>
<a name="l01273"></a>01273       (*mfp_table_a_ptr)[i*(MAX_MATERIALS)+mat].x = 1.0/(d_total_mfp*density_nominal[mat]);   <span class="comment">// inverse TOTAL mfp * nominal density</span>
<a name="l01274"></a>01274       (*mfp_table_a_ptr)[i*(MAX_MATERIALS)+mat].y = 1.0/(d_compton  *density_nominal[mat]);   <span class="comment">// inverse Compton mfp * nominal density</span>
<a name="l01275"></a>01275       (*mfp_table_a_ptr)[i*(MAX_MATERIALS)+mat].z = 1.0/(d_rayleigh *density_nominal[mat]);   <span class="comment">// inverse Rayleigh mfp * nominal density</span>
<a name="l01276"></a>01276 
<a name="l01277"></a>01277       rayleigh_table_ptr-&gt;<a class="code" href="structrayleigh__struct.html#14a41a17bf4ad8a1e87f43d9f42021ad">pmax</a>[i*(MAX_MATERIALS)+mat] = d_pmax;    <span class="comment">// Store the maximum cumulative probability of atomic form factor F^2 for</span>
<a name="l01278"></a>01278 
<a name="l01279"></a>01279       <span class="keywordflow">if</span> (0==i &amp;&amp; 0==mat)
<a name="l01280"></a>01280       {
<a name="l01281"></a>01281         mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a>  = d_energy;   <span class="comment">// Store the first energy of the first material</span>
<a name="l01282"></a>01282       }
<a name="l01283"></a>01283 
<a name="l01284"></a>01284       <span class="keywordflow">if</span> (0==i)
<a name="l01285"></a>01285       {
<a name="l01286"></a>01286         <span class="keywordflow">if</span> (fabs(d_energy-mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a>)&gt;1.0e-9)
<a name="l01287"></a>01287         {
<a name="l01288"></a>01288           printf(<span class="stringliteral">"\n\n   !!load_material ERROR!! Incorrect first energy value given in material \'%s\': input=%f, expected=%f\n"</span>, file_name_materials[mat], d_energy, mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a>);
<a name="l01289"></a>01289           exit(-2);
<a name="l01290"></a>01290         }
<a name="l01291"></a>01291       }
<a name="l01292"></a>01292       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (1==i)
<a name="l01293"></a>01293       {
<a name="l01294"></a>01294         delta_e = d_energy-e_last;
<a name="l01295"></a>01295       }
<a name="l01296"></a>01296       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i&gt;1)
<a name="l01297"></a>01297       {
<a name="l01298"></a>01298         <span class="keywordflow">if</span> (((fabs((d_energy-e_last)-delta_e))/delta_e)&gt;0.001)  <span class="comment">// Tolerate up to a 0.1% relative variation in the delta e (for each bin) to account for possible precission errors reading the energy values</span>
<a name="l01299"></a>01299         {
<a name="l01300"></a>01300           printf(<span class="stringliteral">"  !!ERROR reading material data!! The energy step between mean free path values is not constant!!\n      (maybe not enough decimals given for the energy values)\n      #value = %d, First delta: %f , New delta: %f, Energy: %f ; Rel.Dif=%f\n"</span>, i, delta_e, (d_energy-e_last), d_energy,((fabs((d_energy-e_last)-delta_e))/delta_e));
<a name="l01301"></a>01301           exit(-2);
<a name="l01302"></a>01302         }
<a name="l01303"></a>01303       }
<a name="l01304"></a>01304       e_last = d_energy;
<a name="l01305"></a>01305     }
<a name="l01306"></a>01306     
<a name="l01307"></a>01307     <span class="keywordflow">if</span> (0==mat) <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"                Minimum energy = %f, Maximum = %f; Delta E (1st bin) = %f\n"</span>, (mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a>), e_last, delta_e);
<a name="l01308"></a>01308 
<a name="l01309"></a>01309     <span class="comment">// -- Store the inverse of delta energy:</span>
<a name="l01310"></a>01310     mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#4b743ecf01ca7d075cc6b36b9ce2f0a1">ide</a> = 1.0f/delta_e;
<a name="l01311"></a>01311 
<a name="l01312"></a>01312     <span class="comment">// -- Store MFP data slope 'b' (.y for Woodcock):</span>
<a name="l01313"></a>01313     <span class="keywordflow">for</span> (i=0; i&lt;(input_num_values-1); i++)
<a name="l01314"></a>01314     {
<a name="l01315"></a>01315       bin = i*MAX_MATERIALS+mat;                   <span class="comment">// Set current bin, skipping MAX_MATERIALS columns</span>
<a name="l01316"></a>01316       (*mfp_table_b_ptr)[bin].x = ((*mfp_table_a_ptr)[bin+MAX_MATERIALS].x - (*mfp_table_a_ptr)[bin].x) / delta_e;
<a name="l01317"></a>01317       (*mfp_table_b_ptr)[bin].y = ((*mfp_table_a_ptr)[bin+MAX_MATERIALS].y - (*mfp_table_a_ptr)[bin].y) / delta_e;
<a name="l01318"></a>01318       (*mfp_table_b_ptr)[bin].z = ((*mfp_table_a_ptr)[bin+MAX_MATERIALS].z - (*mfp_table_a_ptr)[bin].z) / delta_e;
<a name="l01319"></a>01319     }
<a name="l01320"></a>01320     <span class="comment">// After maximum energy (last bin), assume constant slope:</span>
<a name="l01321"></a>01321     (*mfp_table_b_ptr)[(input_num_values-1)*MAX_MATERIALS+mat] = (*mfp_table_b_ptr)[(input_num_values-2)*MAX_MATERIALS+mat];
<a name="l01322"></a>01322 
<a name="l01323"></a>01323     <span class="comment">// -- Rescale the 'a' parameter (.x for Woodcock) as if the bin started at energy = 0: we will not have to rescale to the bin minimum energy every time</span>
<a name="l01324"></a>01324     <span class="keywordflow">for</span> (i=0; i&lt;input_num_values; i++)
<a name="l01325"></a>01325     {
<a name="l01326"></a>01326       d_energy = mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a> + i*delta_e;   <span class="comment">// Set current bin lowest energy value</span>
<a name="l01327"></a>01327       bin = i*MAX_MATERIALS+mat;                   <span class="comment">// Set current bin, skipping MAX_MATERIALS columns</span>
<a name="l01328"></a>01328       (*mfp_table_a_ptr)[bin].x = (*mfp_table_a_ptr)[bin].x - d_energy*(*mfp_table_b_ptr)[bin].x;
<a name="l01329"></a>01329       (*mfp_table_a_ptr)[bin].y = (*mfp_table_a_ptr)[bin].y - d_energy*(*mfp_table_b_ptr)[bin].y;
<a name="l01330"></a>01330       (*mfp_table_a_ptr)[bin].z = (*mfp_table_a_ptr)[bin].z - d_energy*(*mfp_table_b_ptr)[bin].z;
<a name="l01331"></a>01331     }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333     <span class="comment">// -- Reading data for RAYLEIGH INTERACTIONS (RITA sampling  of atomic form factor from EPDL database):</span>
<a name="l01334"></a>01334     <span class="keywordflow">do</span>
<a name="l01335"></a>01335     {
<a name="l01336"></a>01336       fgets(new_line, 250, file_ptr);
<a name="l01337"></a>01337       <span class="keywordflow">if</span> (feof(file_ptr)!=0)
<a name="l01338"></a>01338       {
<a name="l01339"></a>01339         printf(<span class="stringliteral">"\n\n   !!End-of-file ERROR!! Rayleigh data not found: \"#[DATA VALUES...\" in file \'%s\'. Last line read: %s\n\n"</span>, file_name_materials[mat], new_line);
<a name="l01340"></a>01340         exit(-2);
<a name="l01341"></a>01341       }
<a name="l01342"></a>01342     }
<a name="l01343"></a>01343     <span class="keywordflow">while</span>(strstr(new_line,<span class="stringliteral">"[DATA VALUES"</span>)==NULL);   <span class="comment">// Skip all lines until this text is found</span>
<a name="l01344"></a>01344       
<a name="l01345"></a>01345     fgets(new_line, 250, file_ptr);     <span class="comment">// Read the number of data points in Rayleigh</span>
<a name="l01346"></a>01346     sscanf(new_line, <span class="stringliteral">"# %d"</span>, &amp;input_rayleigh_values);
<a name="l01347"></a>01347         
<a name="l01348"></a>01348     <span class="keywordflow">if</span> (input_rayleigh_values != NP_RAYLEIGH)
<a name="l01349"></a>01349     {
<a name="l01350"></a>01350       printf(<span class="stringliteral">"\n\n   !!ERROR!! The number of values for Rayleigh sampling is different than the allocated space: input=%d, NP_RAYLEIGH=%d. File=\'%s\'\n"</span>, input_rayleigh_values, NP_RAYLEIGH, file_name_materials[mat]);
<a name="l01351"></a>01351       exit(-2);
<a name="l01352"></a>01352     }
<a name="l01353"></a>01353     fgets(new_line, 250, file_ptr);    <span class="comment">// Comment line:  #[SAMPLING DATA FROM COMMON/CGRA/: X, P, A, B, ITL, ITU]</span>
<a name="l01354"></a>01354     <span class="keywordflow">for</span> (i=0; i&lt;input_rayleigh_values; i++)
<a name="l01355"></a>01355     {
<a name="l01356"></a>01356       <span class="keywordtype">int</span> itlco_tmp, ituco_tmp;
<a name="l01357"></a>01357       bin = NP_RAYLEIGH*mat + i;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359       fgets(new_line, 250, file_ptr);
<a name="l01360"></a>01360       sscanf(new_line,<span class="stringliteral">"  %e  %e  %e  %e  %d  %d"</span>, &amp;(rayleigh_table_ptr-&gt;<a class="code" href="structrayleigh__struct.html#3d91ed8dc782c166106093ae028f0dd8">xco</a>[bin]), &amp;(rayleigh_table_ptr-&gt;<a class="code" href="structrayleigh__struct.html#85ba59a95287c8d2ec3895b9ea6f8f43">pco</a>[bin]),
<a name="l01361"></a>01361                                                   &amp;(rayleigh_table_ptr-&gt;<a class="code" href="structrayleigh__struct.html#2ea1b62a4e4cc5900c060fed2d95fec5">aco</a>[bin]), &amp;(rayleigh_table_ptr-&gt;<a class="code" href="structrayleigh__struct.html#f107a7fbdd989e049ba67b9fc2e614c3">bco</a>[bin]),
<a name="l01362"></a>01362                                                   &amp;itlco_tmp, &amp;ituco_tmp);
<a name="l01363"></a>01363 
<a name="l01364"></a>01364       rayleigh_table_ptr-&gt;<a class="code" href="structrayleigh__struct.html#81e58bece94cd34133d55960cee9fe73">itlco</a>[bin] = (<span class="keywordtype">unsigned</span> char) itlco_tmp;
<a name="l01365"></a>01365       rayleigh_table_ptr-&gt;<a class="code" href="structrayleigh__struct.html#f8eb91b5cbbc3bdf6d84e3aa9525946a">ituco</a>[bin] = (<span class="keywordtype">unsigned</span> char) ituco_tmp;
<a name="l01366"></a>01366                                                   
<a name="l01367"></a>01367     }
<a name="l01368"></a>01368     <span class="comment">//  printf("    -- Rayleigh sampling data read. Input values = %d\n",input_rayleigh_values);</span>
<a name="l01369"></a>01369 
<a name="l01370"></a>01370     <span class="comment">// -- Reading COMPTON INTERACTIONS data (relativistic impulse model with approximated one-electron analytical profiles):</span>
<a name="l01371"></a>01371     <span class="keywordflow">do</span>
<a name="l01372"></a>01372     {
<a name="l01373"></a>01373       fgets(new_line, 250, file_ptr);
<a name="l01374"></a>01374       <span class="keywordflow">if</span> (feof(file_ptr)!=0)
<a name="l01375"></a>01375       {
<a name="l01376"></a>01376         printf(<span class="stringliteral">"\n\n   !!End-of-file ERROR!! Compton data not found: \"[NUMBER OF SHELLS]\" in file \'%s\'. Last line read: %s\n\n"</span>, file_name_materials[mat], new_line);
<a name="l01377"></a>01377         exit(-2);
<a name="l01378"></a>01378       }
<a name="l01379"></a>01379     }
<a name="l01380"></a>01380     <span class="keywordflow">while</span>(strstr(new_line,<span class="stringliteral">"[NUMBER OF SHELLS"</span>)==NULL);   <span class="comment">// Skip all lines until this text is found</span>
<a name="l01381"></a>01381     fgets(new_line, 250, file_ptr);
<a name="l01382"></a>01382     sscanf(new_line, <span class="stringliteral">"# %d"</span>, &amp;input_num_shells);      <span class="comment">// Read the NUMBER OF SHELLS</span>
<a name="l01383"></a>01383     <span class="keywordflow">if</span> (input_num_shells&gt;MAX_SHELLS)
<a name="l01384"></a>01384     {
<a name="l01385"></a>01385       printf(<span class="stringliteral">"\n\n   !!ERROR!! Too many shells for Compton interactions in file \'%s\': input=%d, MAX_SHELLS=%d\n"</span>, file_name_materials[mat], input_num_shells, MAX_SHELLS);
<a name="l01386"></a>01386       exit(-2);
<a name="l01387"></a>01387     }
<a name="l01388"></a>01388     compton_table_ptr-&gt;<a class="code" href="structcompton__struct.html#ef81eb007c90d13552ea867912f0d2c3">noscco</a>[mat] = input_num_shells;   <span class="comment">// Store number of shells for this material in structure</span>
<a name="l01389"></a>01389     fgets(new_line, 250, file_ptr);    <span class="comment">// Comment line:  #[SHELL INFORMATION FROM COMMON/CGCO/: FCO, UICO, FJ0, KZCO, KSCO]</span>
<a name="l01390"></a>01390     <span class="keywordtype">int</span> kzco_dummy, ksco_dummy;
<a name="l01391"></a>01391     <span class="keywordflow">for</span> (i=0; i&lt;input_num_shells; i++)
<a name="l01392"></a>01392     {
<a name="l01393"></a>01393 
<a name="l01394"></a>01394         <span class="comment">// !!DeBuG!! OLD wrong sorting: bin = i + mat*input_num_shells;</span>
<a name="l01395"></a>01395       bin = mat + i*MAX_MATERIALS;
<a name="l01396"></a>01396 
<a name="l01397"></a>01397       fgets(new_line, 250, file_ptr);
<a name="l01398"></a>01398       sscanf(new_line,<span class="stringliteral">" %e  %e  %e  %d  %d"</span>, &amp;(compton_table_ptr-&gt;<a class="code" href="structcompton__struct.html#181131326c64f04da9eb7f199604371e">fco</a>[bin]), &amp;(compton_table_ptr-&gt;<a class="code" href="structcompton__struct.html#32dcebc4af75e0620abed9c32ffc2bdd">uico</a>[bin]),
<a name="l01399"></a>01399                                               &amp;(compton_table_ptr-&gt;<a class="code" href="structcompton__struct.html#2acdfc304123cea06abea723b5b28d38">fj0</a>[bin]), &amp;kzco_dummy, &amp;ksco_dummy);
<a name="l01400"></a>01400     }
<a name="l01401"></a>01401   
<a name="l01402"></a>01402     fclose(file_ptr);    <span class="comment">// Material data read. Close the current material input file</span>
<a name="l01403"></a>01403     
<a name="l01404"></a>01404   }  <span class="comment">// ["for" loop: continue with next material]</span>
<a name="l01405"></a>01405 
<a name="l01406"></a>01406 
<a name="l01407"></a>01407   <span class="comment">// -- Store Woodcock MFP slope in component '.y':</span>
<a name="l01408"></a>01408   <span class="keywordflow">for</span> (i=0; i&lt;(mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#2bea2f84374be1b9afd5d896b16a7a46">num_values</a>-1); i++)
<a name="l01409"></a>01409     (*mfp_Woodcock_table_ptr)[i].y = ((*mfp_Woodcock_table_ptr)[i+1].x - (*mfp_Woodcock_table_ptr)[i].x)/delta_e;
<a name="l01410"></a>01410 
<a name="l01411"></a>01411       <span class="comment">//  !!DeBuG!! OLD: wrong?? dividing by bin energy, not bin width!!:  (*mfp_Woodcock_table_ptr)[i].y = ((*mfp_Woodcock_table_ptr)[i+1].x - (*mfp_Woodcock_table_ptr)[i].x)/(mfp_table_data-&gt;e0 + i*delta_e);</span>
<a name="l01412"></a>01412 
<a name="l01413"></a>01413   <span class="comment">// -- Rescale the first parameter in component .x for Woodcock</span>
<a name="l01414"></a>01414   <span class="keywordflow">for</span> (i=0; i&lt;mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#2bea2f84374be1b9afd5d896b16a7a46">num_values</a>; i++)
<a name="l01415"></a>01415   {
<a name="l01416"></a>01416     (*mfp_Woodcock_table_ptr)[i].x = (*mfp_Woodcock_table_ptr)[i].x - (mfp_table_data-&gt;<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a> + i*delta_e)*(*mfp_Woodcock_table_ptr)[i].y;
<a name="l01417"></a>01417   }
<a name="l01418"></a>01418   
<a name="l01419"></a>01419 }<span class="comment"></span>
<a name="l01420"></a>01420 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01421"></a>01421 <span class="comment"></span>
<a name="l01422"></a>01422 
<a name="l01423"></a>01423 
<a name="l01424"></a>01424 <span class="preprocessor">#ifdef USING_CUDA</span><span class="comment"></span>
<a name="l01425"></a>01425 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01426"></a>01426 <span class="comment">//!  Sets the CUDA enabled GPU that will be used in the simulation.</span>
<a name="l01427"></a>01427 <span class="comment">//!  Allocates and copies the simulation data in the GPU global and constant memories.</span>
<a name="l01428"></a>01428 <span class="comment">//!</span>
<a name="l01429"></a>01429 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01430"></a>01430 <span class="comment"></span>void init_CUDA_device( int* gpu_id, int myID,
<a name="l01431"></a>01431       <span class="comment">/*Variables to GPU constant memory:*/</span> <span class="keyword">struct </span><a class="code" href="structvoxel__struct.html" title="Structure defining a voxelized box with the back-lower corner at the coordinate origin...">voxel_struct</a>* voxel_data, <span class="keyword">struct </span><a class="code" href="structsource__struct.html" title="Structure storing the data defining the source model.">source_struct</a>* source_data, <span class="keyword">struct </span><a class="code" href="structdetector__struct.html" title="Structure storing the data defining the x-ray detector.">detector_struct</a>* detector_data, <span class="keyword">struct </span><a class="code" href="structlinear__interp.html" title="Structure with the basic data required by the linear interpolation of the mean free...">linear_interp</a>* mfp_table_data,
<a name="l01432"></a>01432       <span class="comment">/*Variables to GPU global memory:*/</span> float2* voxel_mat_dens, float2** voxel_mat_dens_device, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> voxel_mat_dens_bytes,
<a name="l01433"></a>01433         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>* image, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>** image_device, <span class="keywordtype">int</span> image_bytes,
<a name="l01434"></a>01434         float2* mfp_Woodcock_table, float2** mfp_Woodcock_table_device, <span class="keywordtype">int</span> mfp_Woodcock_table_bytes,
<a name="l01435"></a>01435         float3* mfp_table_a, float3* mfp_table_b, float3** mfp_table_a_device, float3** mfp_table_b_device, <span class="keywordtype">int</span> mfp_table_bytes,
<a name="l01436"></a>01436         <span class="keyword">struct </span><a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a>* rayleigh_table, <span class="keyword">struct </span><a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a>** rayleigh_table_device,
<a name="l01437"></a>01437         <span class="keyword">struct </span><a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a>* compton_table, <span class="keyword">struct </span><a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a>** compton_table_device )
<a name="l01438"></a>01438 {
<a name="l01439"></a>01439   <span class="keywordtype">int</span> deviceCount;
<a name="l01440"></a>01440   cutilSafeCall(cudaGetDeviceCount(&amp;deviceCount));
<a name="l01441"></a>01441   <span class="keywordflow">if</span> (0==deviceCount)
<a name="l01442"></a>01442   {
<a name="l01443"></a>01443     printf(<span class="stringliteral">"\n  !!ERROR!! No CUDA enabled GPU detected!!\n\n"</span>);
<a name="l01444"></a>01444     exit(-1);
<a name="l01445"></a>01445   }
<a name="l01446"></a>01446   <span class="keywordflow">if</span> ( ((*gpu_id)&gt;(deviceCount-1)) || ((*gpu_id)&lt;0) )
<a name="l01447"></a>01447   {
<a name="l01448"></a>01448     printf(<span class="stringliteral">"\n  !!WARNING!! The input GPU number is not valid: input_GPU=%d, maximum GPU number=%d.\n"</span>, (*gpu_id), deviceCount-1);
<a name="l01449"></a>01449     <span class="comment">// printf("              The device with the maximum Gflop count will be automatically selected.\n");</span>
<a name="l01450"></a>01450     <span class="comment">// (*gpu_id) = cutGetMaxGflopsDeviceId();</span>
<a name="l01451"></a>01451     exit(-3);
<a name="l01452"></a>01452   }
<a name="l01453"></a>01453 
<a name="l01454"></a>01454   cutilSafeCall(cudaSetDevice(*gpu_id));   <span class="comment">// Set the GPU device.</span>
<a name="l01455"></a>01455 
<a name="l01456"></a>01456   cudaDeviceProp deviceProp;
<a name="l01457"></a>01457   cutilSafeCall(cudaGetDeviceProperties(&amp;deviceProp, *gpu_id));
<a name="l01458"></a>01458   <span class="keywordflow">if</span> (deviceProp.major&gt;99 || deviceProp.minor&gt;99)
<a name="l01459"></a>01459   {
<a name="l01460"></a>01460     printf(<span class="stringliteral">"\n  !!ERROR!! The selected GPU device does not support CUDA!! GPU_id=%d, deviceCount=%d, compute capability=%d.%d\n\n"</span>, (*gpu_id), deviceCount, deviceProp.major,deviceProp.minor);
<a name="l01461"></a>01461     exit(-1);
<a name="l01462"></a>01462   }
<a name="l01463"></a>01463 
<a name="l01464"></a>01464   <span class="comment">// -- Reading the device properties as shown in NVIDIA's SDK sample code "deviceQuery"</span>
<a name="l01465"></a>01465   printf(<span class="stringliteral">"\n       ==&gt; CUDA: %d CUDA enabled GPU detected! Using device #%d: \"%s\"\n"</span>, deviceCount, (*gpu_id), deviceProp.name);
<a name="l01466"></a>01466   printf(<span class="stringliteral">"                 Compute capability: %d.%d, Number multiprocessors: %d, Number cores: %d\n"</span>, deviceProp.major, deviceProp.minor, deviceProp.multiProcessorCount, 8*deviceProp.multiProcessorCount);
<a name="l01467"></a>01467   printf(<span class="stringliteral">"                 Clock rate: %.2f GHz, Global memory: %.3f Mbyte, Constant memory: %.2f kbyte\n"</span>, deviceProp.clockRate*1.0e-6f, deviceProp.totalGlobalMem/(1024.f*1024.f), deviceProp.totalConstMem/1024.f);
<a name="l01468"></a>01468   printf(<span class="stringliteral">"                 Shared memory per block: %.2f kbyte, Registers per block: %.2f kbyte\n"</span>, deviceProp.sharedMemPerBlock/1024.f, deviceProp.regsPerBlock/1024.f);
<a name="l01469"></a>01469 
<a name="l01470"></a>01470 
<a name="l01471"></a>01471   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timer = 0;
<a name="l01472"></a>01472   cutilCheckError(cutCreateTimer(&amp;timer));
<a name="l01473"></a>01473   cutilCheckError(cutStartTimer(timer));
<a name="l01474"></a>01474 
<a name="l01475"></a>01475   <span class="comment">// -- Allocate the constant variables in the device:</span>
<a name="l01476"></a>01476   cutilSafeCall(cudaMemcpyToSymbol(<span class="stringliteral">"voxel_data_CONST"</span>,     voxel_data,     <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structvoxel__struct.html" title="Structure defining a voxelized box with the back-lower corner at the coordinate origin...">voxel_struct</a>)));
<a name="l01477"></a>01477   cutilSafeCall(cudaMemcpyToSymbol(<span class="stringliteral">"source_data_CONST"</span>,    source_data,    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structsource__struct.html" title="Structure storing the data defining the source model.">source_struct</a>)));
<a name="l01478"></a>01478   cutilSafeCall(cudaMemcpyToSymbol(<span class="stringliteral">"detector_data_CONST"</span>,  detector_data,  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structdetector__struct.html" title="Structure storing the data defining the x-ray detector.">detector_struct</a>)));
<a name="l01479"></a>01479   cutilSafeCall(cudaMemcpyToSymbol(<span class="stringliteral">"mfp_table_data_CONST"</span>, mfp_table_data, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structlinear__interp.html" title="Structure with the basic data required by the linear interpolation of the mean free...">linear_interp</a>)));
<a name="l01480"></a>01480 
<a name="l01481"></a>01481   <span class="keywordtype">double</span> total_mem = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structvoxel__struct.html" title="Structure defining a voxelized box with the back-lower corner at the coordinate origin...">voxel_struct</a>)+sizeof(struct <a class="code" href="structsource__struct.html" title="Structure storing the data defining the source model.">source_struct</a>)+sizeof(struct <a class="code" href="structdetector__struct.html" title="Structure storing the data defining the x-ray detector.">detector_struct</a>)+sizeof(struct <a class="code" href="structlinear__interp.html" title="Structure with the basic data required by the linear interpolation of the mean free...">linear_interp</a>);
<a name="l01482"></a>01482   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       ==&gt; CUDA: Structures successfully copied to the device. CONSTANT memory used: %lf kbytes (%.1lf%%)\n"</span>, total_mem/1024.0, 100.0*total_mem/deviceProp.totalConstMem);
<a name="l01483"></a>01483 
<a name="l01484"></a>01484   <span class="comment">// -- Allocate the device memory:</span>
<a name="l01485"></a>01485   cutilSafeCall(cudaMalloc((<span class="keywordtype">void</span>**) voxel_mat_dens_device, voxel_mat_dens_bytes));
<a name="l01486"></a>01486   cutilSafeCall(cudaMalloc((<span class="keywordtype">void</span>**) image_device, image_bytes));
<a name="l01487"></a>01487   cutilSafeCall(cudaMalloc((<span class="keywordtype">void</span>**) mfp_Woodcock_table_device, mfp_Woodcock_table_bytes));
<a name="l01488"></a>01488   cutilSafeCall(cudaMalloc((<span class="keywordtype">void</span>**) mfp_table_a_device, mfp_table_bytes));
<a name="l01489"></a>01489   cutilSafeCall(cudaMalloc((<span class="keywordtype">void</span>**) mfp_table_b_device, mfp_table_bytes));
<a name="l01490"></a>01490   cutilSafeCall(cudaMalloc((<span class="keywordtype">void</span>**) rayleigh_table_device, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a>)));
<a name="l01491"></a>01491   cutilSafeCall(cudaMalloc((<span class="keywordtype">void</span>**) compton_table_device,  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a>)));
<a name="l01492"></a>01492 
<a name="l01493"></a>01493   total_mem = voxel_mat_dens_bytes+image_bytes+mfp_Woodcock_table_bytes+2*mfp_table_bytes+<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a>)+sizeof(struct <a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a>);
<a name="l01494"></a>01494   <span class="keywordflow">if</span> (*voxel_mat_dens_device==NULL || *image_device==NULL || *mfp_Woodcock_table_device==NULL ||
<a name="l01495"></a>01495       *mfp_table_a_device==NULL || *mfp_table_a_device==NULL || *rayleigh_table_device==NULL || *compton_table_device==NULL)
<a name="l01496"></a>01496   {
<a name="l01497"></a>01497     printf(<span class="stringliteral">"\n cudaMalloc ERROR!! Device global memory not correctly allocated!! (%lf Mbytes)\n"</span>, total_mem/(1024.0*1024.0));
<a name="l01498"></a>01498     exit(-1);
<a name="l01499"></a>01499   }
<a name="l01500"></a>01500   <span class="keywordflow">else</span>
<a name="l01501"></a>01501   {
<a name="l01502"></a>01502     <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       ==&gt; CUDA: Device global memory correctly allocated. GLOBAL memory used: %lf Mbytes (%.1lf%%)\n"</span>, total_mem/(1024.0*1024.0), 100.0*total_mem/deviceProp.totalGlobalMem);
<a name="l01503"></a>01503   }
<a name="l01504"></a>01504 
<a name="l01505"></a>01505   <span class="comment">// --Copy the host memory to the device:</span>
<a name="l01506"></a>01506   cutilSafeCall(cudaMemcpy(*voxel_mat_dens_device, voxel_mat_dens, voxel_mat_dens_bytes, cudaMemcpyHostToDevice));
<a name="l01507"></a>01507   cutilSafeCall(cudaMemcpy(*mfp_Woodcock_table_device, mfp_Woodcock_table, mfp_Woodcock_table_bytes, cudaMemcpyHostToDevice));
<a name="l01508"></a>01508   cutilSafeCall(cudaMemcpy(*mfp_table_a_device, mfp_table_a, mfp_table_bytes, cudaMemcpyHostToDevice));
<a name="l01509"></a>01509   cutilSafeCall(cudaMemcpy(*mfp_table_b_device, mfp_table_b, mfp_table_bytes, cudaMemcpyHostToDevice));
<a name="l01510"></a>01510   cutilSafeCall(cudaMemcpy(*rayleigh_table_device, rayleigh_table, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a>), cudaMemcpyHostToDevice));
<a name="l01511"></a>01511   cutilSafeCall(cudaMemcpy(*compton_table_device, compton_table, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a>), cudaMemcpyHostToDevice));
<a name="l01512"></a>01512 
<a name="l01513"></a>01513 
<a name="l01514"></a>01514   <span class="comment">//   --Init the image array to 0 using a GPU kernel instead of cudaMemcpy:</span>
<a name="l01515"></a>01515   <span class="comment">//     Simple version: cutilSafeCall( cudaMemcpy( image_device, image, image_bytes, cudaMemcpyHostToDevice) );</span>
<a name="l01516"></a>01516 
<a name="l01517"></a>01517   <span class="keywordtype">int</span> pixels_per_image = detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x * detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y;
<a name="l01518"></a>01518   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"       ==&gt; CUDA: Launching kernel to initialize device image to 0: number of blocks = %d, threads per block = 128\n"</span>, (<span class="keywordtype">int</span>)ceil(pixels_per_image/128.0f) );
<a name="l01519"></a>01519 
<a name="l01520"></a>01520   <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#0ea66eae6d288c9e4d2456ee1033429f" title="Initialize the image array, ie, set all pixels to zero Essentially, this function...">init_image_array_GPU</a>&lt;&lt;&lt;(int)(ceil(pixels_per_image/128.0f)),128&gt;&gt;&gt;(*image_device, pixels_per_image);
<a name="l01521"></a>01521     cudaThreadSynchronize();      <span class="comment">// Force the runtime to wait until all device tasks have completed</span>
<a name="l01522"></a>01522     cutilCheckMsg(<span class="stringliteral">" !!Kernel execution failed initializing the image array!! "</span>);  <span class="comment">// Check if kernel execution generated any error:</span>
<a name="l01523"></a>01523 
<a name="l01524"></a>01524   cutilCheckError(cutStopTimer(timer));
<a name="l01525"></a>01525   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"                 Time spent allocating and copying memory to the device: %.6f s\n"</span>, 0.001f*cutGetTimerValue( timer));
<a name="l01526"></a>01526   cutilCheckError(cutDeleteTimer(timer));
<a name="l01527"></a>01527 
<a name="l01528"></a>01528 }
<a name="l01529"></a>01529 <span class="preprocessor">#endif</span><span class="comment"></span>
<a name="l01530"></a>01530 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01531"></a>01531 <span class="comment"></span>
<a name="l01532"></a>01532 
<a name="l01533"></a>01533 <span class="comment"></span>
<a name="l01534"></a>01534 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01535"></a>01535 <span class="comment">//! Report the final results, from the host CPU.</span>
<a name="l01536"></a>01536 <span class="comment">//!</span>
<a name="l01537"></a>01537 <span class="comment">//!       @param[in] file_name_output   File where tallied image is reported</span>
<a name="l01538"></a>01538 <span class="comment">//!       @param[in] detector_data   Detector description read from the input file (pointer to detector_struct)</span>
<a name="l01539"></a>01539 <span class="comment">//!       @param[in] image  Tallied image (in meV per pixel)</span>
<a name="l01540"></a>01540 <span class="comment">//!       @param[in] time_elapsed   Time elapsed during the main loop execution (in seconds)</span>
<a name="l01541"></a>01541 <span class="comment">//!       @param[in] total_histories   Total number of x-rays simulated</span>
<a name="l01542"></a>01542 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01543"></a><a class="code" href="MC-GPU__v1_81_8h.html#39db69f5efdcc4012bddf911e8a78691">01543</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="MC-GPU__v1_81_8cu.html#39db69f5efdcc4012bddf911e8a78691" title="Report the final results, from the host CPU.">report_host</a>(<span class="keywordtype">char</span>* file_name_output, <span class="keyword">struct</span> <a class="code" href="structdetector__struct.html" title="Structure storing the data defining the x-ray detector.">detector_struct</a>* detector_data, <span class="keyword">struct</span> <a class="code" href="structsource__struct.html" title="Structure storing the data defining the source model.">source_struct</a>* source_data, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>* image, <span class="keywordtype">double</span> time_elapsed, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> total_histories, <span class="keywordtype">int</span> current_projection, <span class="keywordtype">int</span> num_projections, <span class="keywordtype">double</span> D_angle, <span class="keywordtype">double</span> initial_angle, <span class="keywordtype">int</span> myID, <span class="keywordtype">int</span> numprocs)
<a name="l01544"></a>01544 {
<a name="l01545"></a>01545     <span class="comment">// printf("\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");</span>
<a name="l01546"></a>01546     <span class="comment">// printf("           ~~ Simulation performance quick report ~~\n");</span>
<a name="l01547"></a>01547     <span class="comment">// printf("           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");</span>
<a name="l01548"></a>01548 
<a name="l01549"></a>01549 
<a name="l01550"></a>01550   <span class="comment">//  -Find current angle</span>
<a name="l01551"></a>01551   <span class="keywordtype">double</span> current_angle = initial_angle+current_projection*D_angle;
<a name="l01552"></a>01552     <span class="keywordflow">if</span> (current_angle&lt;0.0)
<a name="l01553"></a>01553     current_angle += 2.0*PI;   <span class="comment">// Make sure the angle is not negative.</span>
<a name="l01554"></a>01554   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (current_angle&gt;=2.0*PI)
<a name="l01555"></a>01555     current_angle -= 2.0*PI;   <span class="comment">// Make sure the angle is not above 360 degrees.</span>
<a name="l01556"></a>01556 
<a name="l01557"></a>01557   <span class="comment">// -- Report data:</span>
<a name="l01558"></a>01558   printf(<span class="stringliteral">"\n          *** SIMULATION PERFORMANCE REPORT ***\n"</span>);
<a name="l01559"></a>01559   <span class="keywordflow">if</span>(num_projections!=1)   <span class="comment">// Output the projection angle when simulating a CT:</span>
<a name="l01560"></a>01560     printf(<span class="stringliteral">"              Projection %d of %d. Angle from X axis: %lf\n"</span>, current_projection, num_projections-1, current_angle*RAD2DEG);
<a name="l01561"></a>01561 <span class="preprocessor">#ifdef USING_MPI</span>
<a name="l01562"></a>01562 <span class="preprocessor"></span>  printf(<span class="stringliteral">"              Computed by the MPI thread %d of %d\n"</span>, myID, numprocs);
<a name="l01563"></a>01563 <span class="preprocessor">#endif</span>
<a name="l01564"></a>01564 <span class="preprocessor"></span>  printf(<span class="stringliteral">"              Simulated x rays:    %lld\n"</span>, total_histories);
<a name="l01565"></a>01565   printf(<span class="stringliteral">"              Simulation time [s]: %.2f\n"</span>, time_elapsed);
<a name="l01566"></a>01566   <span class="keywordflow">if</span> (time_elapsed&gt;0.000001)
<a name="l01567"></a>01567     printf(<span class="stringliteral">"              Speed [x-rays/s]:    %.2f\n"</span>, ((<span class="keywordtype">double</span>)total_histories)/time_elapsed);
<a name="l01568"></a>01568 
<a name="l01569"></a>01569   FILE* file_ptr = fopen(file_name_output, <span class="stringliteral">"w"</span>);
<a name="l01570"></a>01570   
<a name="l01571"></a>01571   <span class="keywordflow">if</span> (file_ptr==NULL)
<a name="l01572"></a>01572   {
<a name="l01573"></a>01573     printf(<span class="stringliteral">"\n\n   !!fopen ERROR!! File %s can not be opened!!\n"</span>, file_name_output);
<a name="l01574"></a>01574     exit(-3);
<a name="l01575"></a>01575   }
<a name="l01576"></a>01576 
<a name="l01577"></a>01577   fprintf(file_ptr, <span class="stringliteral">"# \n"</span>);
<a name="l01578"></a>01578 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l01579"></a>01579 <span class="preprocessor"></span>  fprintf(file_ptr, <span class="stringliteral">"#  *** SIMULATION IN THE GPU USING CUDA ***\n"</span>);
<a name="l01580"></a>01580 <span class="preprocessor">#else</span>
<a name="l01581"></a>01581 <span class="preprocessor"></span>  fprintf(file_ptr, <span class="stringliteral">"#  *** SIMULATION IN THE CPU ***\n"</span>);
<a name="l01582"></a>01582 <span class="preprocessor">#endif</span>
<a name="l01583"></a>01583 <span class="preprocessor"></span>  fprintf(file_ptr, <span class="stringliteral">"#\n"</span>);
<a name="l01584"></a>01584   fprintf(file_ptr, <span class="stringliteral">"#  Image created counting the energy arriving at each pixel.\n"</span>);
<a name="l01585"></a>01585   fprintf(file_ptr, <span class="stringliteral">"#  Pixel value units: eV/cm^2 per history\n"</span>);
<a name="l01586"></a>01586   <span class="keywordflow">if</span>(num_projections!=1)   <span class="comment">// Output the projection angle when simulating a CT:</span>
<a name="l01587"></a>01587     fprintf(file_ptr, <span class="stringliteral">"#  CT projection %d of %d. Angle from X axis: %lf\n"</span>, current_projection, num_projections-1, current_angle*RAD2DEG);
<a name="l01588"></a>01588 <span class="preprocessor">#ifdef USING_MPI</span>
<a name="l01589"></a>01589 <span class="preprocessor"></span>  fprintf(file_ptr, <span class="stringliteral">"#  Computed by the MPI thread %d of %d\n"</span>, myID, numprocs);
<a name="l01590"></a>01590 <span class="preprocessor">#endif    </span>
<a name="l01591"></a>01591 <span class="preprocessor"></span>  fprintf(file_ptr, <span class="stringliteral">"#  Pixel size:  %lf x %lf = %lf cm^2\n"</span>, 1.0/<span class="keywordtype">double</span>(detector_data-&gt;<a class="code" href="structdetector__struct.html#3c6f9e59e89db06211ccea63287e2826">inv_pixel_size_X</a>), 1.0/<span class="keywordtype">double</span>(detector_data-&gt;<a class="code" href="structdetector__struct.html#a91fc94f674ad7af8eca577f4d8cd22b">inv_pixel_size_Z</a>), 1.0/<span class="keywordtype">double</span>(detector_data-&gt;<a class="code" href="structdetector__struct.html#3c6f9e59e89db06211ccea63287e2826">inv_pixel_size_X</a>*detector_data-&gt;<a class="code" href="structdetector__struct.html#a91fc94f674ad7af8eca577f4d8cd22b">inv_pixel_size_Z</a>));
<a name="l01592"></a>01592   fprintf(file_ptr, <span class="stringliteral">"#  Number of pixels in X and Z:  %d  %d\n"</span>, detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x, detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y);
<a name="l01593"></a>01593   fprintf(file_ptr, <span class="stringliteral">"#  (X rows given first, a blank line separates the different Z values)\n"</span>);
<a name="l01594"></a>01594   fprintf(file_ptr, <span class="stringliteral">"# \n"</span>);
<a name="l01595"></a>01595   fprintf(file_ptr, <span class="stringliteral">"#  [NON-SCATTERED] [COMPTON] [RAYLEIGH] [MULTIPLE-SCATTING]\n"</span>);
<a name="l01596"></a>01596   fprintf(file_ptr, <span class="stringliteral">"# ==========================================================\n"</span>);
<a name="l01597"></a>01597 
<a name="l01598"></a>01598   <span class="keyword">const</span> <span class="keywordtype">double</span> SCALE = 1.0/<a class="code" href="MC-GPU__v1_81_8h.html#c0c03cf5e803404f5dc2a42467395a3a" title="Value to scale the deposited energy in the pixels so that it can be stored as a long...">SCALE_eV</a>;    <span class="comment">// conversion to eV using the inverse of the constant used in the "tally_image" kernel function (defined in the header file)</span>
<a name="l01599"></a>01599   <span class="keyword">const</span> <span class="keywordtype">double</span> NORM = SCALE * detector_data-&gt;<a class="code" href="structdetector__struct.html#3c6f9e59e89db06211ccea63287e2826">inv_pixel_size_X</a> * detector_data-&gt;<a class="code" href="structdetector__struct.html#a91fc94f674ad7af8eca577f4d8cd22b">inv_pixel_size_Z</a> / ((double)total_histories);  <span class="comment">// ==&gt; [eV/cm^2 per history]</span>
<a name="l01600"></a>01600   <span class="keywordtype">double</span> energy_noScatter, energy_compton, energy_rayleigh, energy_multiscatter;
<a name="l01601"></a>01601   <span class="keywordtype">double</span> energy_integral = 0.0;   <span class="comment">// Integrate (add) the energy in the image pixels [meV]</span>
<a name="l01602"></a>01602 
<a name="l01603"></a>01603   <span class="keywordtype">int</span> pixels_per_image = (detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x*detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y), pixel=0;
<a name="l01604"></a>01604   <span class="keywordtype">int</span> i, j;
<a name="l01605"></a>01605   <span class="keywordflow">for</span>(j=0; j&lt;detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y; j++)
<a name="l01606"></a>01606   {
<a name="l01607"></a>01607     <span class="keywordflow">for</span>(i=0; i&lt;detector_data-&gt;<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x; i++)
<a name="l01608"></a>01608     {
<a name="l01609"></a>01609       energy_noScatter    = (double)(image[pixel]);
<a name="l01610"></a>01610       energy_compton      = (double)(image[pixel +   pixels_per_image]);
<a name="l01611"></a>01611       energy_rayleigh     = (double)(image[pixel + 2*pixels_per_image]);
<a name="l01612"></a>01612       energy_multiscatter = (double)(image[pixel + 3*pixels_per_image]);
<a name="l01613"></a>01613 
<a name="l01614"></a>01614       <span class="comment">// -- Write the results in an external file; the image corresponding to all particles not written: it has to be infered adding all images</span>
<a name="l01615"></a>01615       fprintf(file_ptr, <span class="stringliteral">"%.8lf %.8lf %.8lf %.8lf\n"</span>, NORM*energy_noScatter, NORM*energy_compton, NORM*energy_rayleigh, NORM*energy_multiscatter);
<a name="l01616"></a>01616 
<a name="l01617"></a>01617       energy_integral += energy_noScatter + energy_compton + energy_rayleigh + energy_multiscatter;
<a name="l01618"></a>01618       pixel++;
<a name="l01619"></a>01619     }
<a name="l01620"></a>01620     fprintf(file_ptr, <span class="stringliteral">"\n"</span>);     <span class="comment">// Separate rows with an empty line for visualization with gnuplot.</span>
<a name="l01621"></a>01621   }
<a name="l01622"></a>01622   fprintf(file_ptr, <span class="stringliteral">"#   *** Simulation REPORT: ***\n"</span>);
<a name="l01623"></a>01623   fprintf(file_ptr, <span class="stringliteral">"#       Fraction energy detected: %.3lf%%\n"</span>, 100.0*SCALE*(energy_integral/(<span class="keywordtype">double</span>)(total_histories))/(<span class="keywordtype">double</span>)(source_data-&gt;<a class="code" href="structsource__struct.html#9e48c14733a7848fa9e038088c18847a">energy</a>));
<a name="l01624"></a>01624   fprintf(file_ptr, <span class="stringliteral">"#       Simulated x rays:    %lld\n"</span>, total_histories);
<a name="l01625"></a>01625   fprintf(file_ptr, <span class="stringliteral">"#       Simulation time [s]: %.2f\n"</span>, time_elapsed);
<a name="l01626"></a>01626   <span class="keywordflow">if</span> (time_elapsed&gt;0.000001)
<a name="l01627"></a>01627     fprintf(file_ptr, <span class="stringliteral">"#       Speed [x-rays/sec]:  %.2f\n\n"</span>, ((<span class="keywordtype">double</span>)total_histories)/time_elapsed);
<a name="l01628"></a>01628 
<a name="l01629"></a>01629   fclose(file_ptr);  <span class="comment">// Close output file and flush stream</span>
<a name="l01630"></a>01630 
<a name="l01631"></a>01631   printf(<span class="stringliteral">"              Fraction of initial energy arriving at the detector (for a monoenergetic beam):  %.3lf%%\n\n"</span>, 100.0*SCALE*(energy_integral/(<span class="keywordtype">double</span>)(total_histories))/(<span class="keywordtype">double</span>)(source_data-&gt;<a class="code" href="structsource__struct.html#9e48c14733a7848fa9e038088c18847a">energy</a>));  <span class="comment">// !!DeBuG!! Caution: Only valid for a monoenergetic beam!</span>
<a name="l01632"></a>01632   fflush(stdout);
<a name="l01633"></a>01633   
<a name="l01634"></a>01634   <span class="keywordflow">return</span> 0;   <span class="comment">// Report could return not 0 to continue the simulation...  !!DeBuG!!</span>
<a name="l01635"></a>01635 }<span class="comment"></span>
<a name="l01636"></a>01636 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
<a name="l01637"></a>01637 <span class="comment"></span>
<a name="l01638"></a>01638 
<a name="l01639"></a>01639 <span class="comment"></span>
<a name="l01640"></a>01640 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
<a name="l01641"></a>01641 <span class="comment">//!  Sets the CT trajectory: store in memory the source and detector rotations</span>
<a name="l01642"></a>01642 <span class="comment">//!  that are needed to calculate the multiple projections.</span>
<a name="l01643"></a>01643 <span class="comment">//!  The first projection (0) was previously initialized in function "read_input".</span>
<a name="l01644"></a>01644 <span class="comment">//!  </span>
<a name="l01645"></a>01645 <span class="comment">//!</span>
<a name="l01646"></a>01646 <span class="comment">//!  ASSUMPTIONS: the CT scan plane must be perpendicular to the Z axis, ie,</span>
<a name="l01647"></a>01647 <span class="comment">//!               the initial direction of the particles must have w=0!</span>
<a name="l01648"></a>01648 <span class="comment">//!</span>
<a name="l01649"></a>01649 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
<a name="l01650"></a><a class="code" href="MC-GPU__v1_81_8h.html#db95164a1253ee2aafeab8a5e0a8e7e3">01650</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="MC-GPU__v1_81_8cu.html#db95164a1253ee2aafeab8a5e0a8e7e3" title="Sets the CT trajectory: store in memory the source and detector rotations that are...">set_CT_trajectory</a>(<span class="keywordtype">int</span> myID, <span class="keywordtype">int</span> num_projections, <span class="keywordtype">double</span> D_angle, <span class="keywordtype">double</span> angularROI_0, <span class="keywordtype">double</span> angularROI_1, <span class="keyword">struct</span> <a class="code" href="structsource__struct.html" title="Structure storing the data defining the source model.">source_struct</a>* source_data, <span class="keyword">struct</span> <a class="code" href="structdetector__struct.html" title="Structure storing the data defining the x-ray detector.">detector_struct</a>* detector_data)
<a name="l01651"></a>01651 {
<a name="l01652"></a>01652   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"\n    -- Setting the sources and detectors for the %d CT projections:\n"</span>, num_projections);
<a name="l01653"></a>01653   <span class="keywordtype">double</span> cos_rX, cos_rZ, sin_rX, sin_rZ, current_angle;
<a name="l01654"></a>01654 
<a name="l01655"></a>01655   <span class="comment">// --Set center of rotation exactly half way between source and detector</span>
<a name="l01656"></a>01656   float3 center_rotation, detector_center;
<a name="l01657"></a>01657   center_rotation.x =  source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].x + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x * (0.5*detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>);
<a name="l01658"></a>01658   center_rotation.y =  source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].y + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y * (0.5*detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>);
<a name="l01659"></a>01659   center_rotation.z =  source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].z;    <span class="comment">//  + source_data-&gt;direction.z * (0.5*detector_data-&gt;sdd);   // !!DeBuG!! w=0 all the time!!</span>
<a name="l01660"></a>01660 
<a name="l01661"></a>01661   <span class="comment">// --Angular span between projections:</span>
<a name="l01662"></a>01662 
<a name="l01663"></a>01663   <span class="comment">//  -Set initial angle for the source (180 degress less than the detector pointed by the direction vector; the zero angle is the X axis, increasing to +Y axis).</span>
<a name="l01664"></a>01664   current_angle = acos((<span class="keywordtype">double</span>)source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x);
<a name="l01665"></a>01665   <span class="keywordflow">if</span> (source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y&lt;0)
<a name="l01666"></a>01666     current_angle = -current_angle;     <span class="comment">// Correct for the fact that positive and negative angles have the same ACOS</span>
<a name="l01667"></a>01667   <span class="keywordflow">if</span> (current_angle&lt;0.0)
<a name="l01668"></a>01668     current_angle += 2.0*PI;   <span class="comment">// Make sure the angle is not negative, between [0,360) degrees.</span>
<a name="l01669"></a>01669   current_angle = current_angle - PI;   <span class="comment">// Correct the fact that the source is opposite to the detector (180 degrees difference).</span>
<a name="l01670"></a>01670   <span class="keywordflow">if</span> (current_angle&lt;0.0)
<a name="l01671"></a>01671     current_angle += 2.0*PI;   <span class="comment">// Make sure the angle is not negative, between [0,360) degrees..</span>
<a name="l01672"></a>01672 
<a name="l01673"></a>01673   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"         &lt;&lt; Projection #0 &gt;&gt; initial_angle=%f , D_angle=%f\n"</span>, current_angle*RAD2DEG, D_angle*RAD2DEG);  <span class="comment">// !!DeBuG!! Verbose</span>
<a name="l01674"></a>01674   <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"                             Source direction=(%f,%f,%f), position=(%f,%f,%f)\n"</span>, source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].x,source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].y,source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[0].z, source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].x,source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].y,source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].z);  <span class="comment">// !!DeBuG!! Verbose</span>
<a name="l01675"></a>01675 
<a name="l01676"></a>01676   <span class="keywordtype">int</span> i;
<a name="l01677"></a>01677   <span class="keywordflow">for</span> (i=1; i&lt;num_projections; i++)   <span class="comment">// The first projection (i=0) was initialized in function "read_input".</span>
<a name="l01678"></a>01678   {
<a name="l01679"></a>01679     <span class="comment">// --Set the new source location and direction, for the current CT projection:</span>
<a name="l01680"></a>01680     current_angle += D_angle;
<a name="l01681"></a>01681     <span class="keywordflow">if</span> (current_angle&gt;=(2.0*PI-0.0001))
<a name="l01682"></a>01682       current_angle -= 2.0*PI;   <span class="comment">// Make sure the angle is not above or equal to 360 degrees.</span>
<a name="l01683"></a>01683 
<a name="l01684"></a>01684       <span class="comment">// -- Check if this projection is inside the angular region of interest</span>
<a name="l01685"></a>01685       <span class="comment">//   if ((current_angle &lt; angularROI_0) || (current_angle &gt; angularROI_1))</span>
<a name="l01686"></a>01686       <span class="comment">//   {</span>
<a name="l01687"></a>01687       <span class="comment">//     printf("            Skipping projection #%d: angle %f outside the angular region of interest.\n", i, current_angle*RAD2DEG);  // !!DeBuG!! Verbose</span>
<a name="l01688"></a>01688       <span class="comment">//     continue;</span>
<a name="l01689"></a>01689       <span class="comment">//   }</span>
<a name="l01690"></a>01690 
<a name="l01691"></a>01691     source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[i].x = center_rotation.x + (0.5*detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>)*cos(current_angle);
<a name="l01692"></a>01692     source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[i].y = center_rotation.y + (0.5*detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>)*sin(current_angle);
<a name="l01693"></a>01693     source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[i].z = source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[0].z;   <span class="comment">//  !!DeBuG!! The Z position must be constant (w=0)!!   !!DeBuG!!</span>
<a name="l01694"></a>01694 
<a name="l01695"></a>01695     source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x = center_rotation.x - source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[i].x;
<a name="l01696"></a>01696     source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y = center_rotation.y - source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[i].y;
<a name="l01697"></a>01697     source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].z = 0.0f;    <span class="comment">//  center_rotation.z - source_data-&gt;position.z;   !!DeBuG!! w=0 all the time!!   !!DeBuG!!</span>
<a name="l01698"></a>01698 
<a name="l01699"></a>01699     <span class="keywordtype">double</span> norm = 1.0/sqrt((<span class="keywordtype">double</span>)source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x*(<span class="keywordtype">double</span>)source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x + (<span class="keywordtype">double</span>)source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y*(<span class="keywordtype">double</span>)source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y <span class="comment">/* + source_data-&gt;direction[i].z*source_data-&gt;direction[i].z*/</span>);
<a name="l01700"></a>01700     source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x = (float)(((<span class="keywordtype">double</span>)source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x)*norm);
<a name="l01701"></a>01701     source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y = (float)(((<span class="keywordtype">double</span>)source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y)*norm);
<a name="l01702"></a>01702       <span class="comment">// source_data-&gt;direction[i].z = (float)(((double)source_data-&gt;direction[i].z)*norm);</span>
<a name="l01703"></a>01703 
<a name="l01704"></a>01704     <span class="comment">// --Set the new detector in front of the new source:</span>
<a name="l01705"></a>01705     detector_center.x = source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[i].x + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x * detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>;   <span class="comment">// Set the center of the detector straight ahead of the focal spot.</span>
<a name="l01706"></a>01706     detector_center.y = source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[i].y + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y * detector_data-&gt;<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>;
<a name="l01707"></a>01707     detector_center.z = source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[i].z;    <span class="comment">//  + source_data-&gt;direction[i].z * detector_data-&gt;sdd;   !!DeBuG!! w=0 all the time!!</span>
<a name="l01708"></a>01708 
<a name="l01709"></a>01709     <span class="keywordtype">double</span> rotX, rotZ;
<a name="l01710"></a>01710 
<a name="l01711"></a>01711       <span class="comment">//  detector_data-&gt;rotation_flag = 1;   // !!DeBuG!! Already set in read_input!</span>
<a name="l01712"></a>01712 
<a name="l01713"></a>01713     <span class="comment">// -- Rotate the detector center to +Y:</span>
<a name="l01714"></a>01714     <span class="comment">//    Set the rotation that will bring particles from the detector plane to +Y=(0,+1,0) through a rotation around X and around Z (counter-clock):</span>
<a name="l01715"></a>01715     rotX = 0.0;   <span class="comment">// !!DeBuG!! w=0 all the time!!  CORRECT CALCULATION:  acos(source_data-&gt;direction.z) - 0.5*PI;  // Rotate to +Y = (0,+1,0) --&gt; rotX_0 =  -PI/2</span>
<a name="l01716"></a>01716 
<a name="l01717"></a>01717     <span class="keywordflow">if</span> ( (source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y) &gt; 1.0e-8 )   <span class="comment">// == u^2+v^2 &gt; 0</span>
<a name="l01718"></a>01718       <span class="keywordflow">if</span> (source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y &gt;= 0.0f)
<a name="l01719"></a>01719         rotZ = 0.5*PI - acos(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x/sqrt(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y));
<a name="l01720"></a>01720       <span class="keywordflow">else</span>
<a name="l01721"></a>01721         rotZ = 0.5*PI - (-acos(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x/sqrt(source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x + source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y*source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y)));
<a name="l01722"></a>01722     <span class="keywordflow">else</span>
<a name="l01723"></a>01723       rotZ = 0.0;   <span class="comment">// Vector pointing to +Z, do not rotate around Z then.</span>
<a name="l01724"></a>01724 
<a name="l01725"></a>01725     <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"         &lt;&lt; Projection #%d &gt;&gt; current_angle=%f, rotation around Z = %f\n"</span>, i, current_angle*RAD2DEG, rotZ*RAD2DEG);  <span class="comment">// !!DeBuG!! Verbose</span>
<a name="l01726"></a>01726     <a class="code" href="MC-GPU__v1_81_8h.html#155f8b8dae8b676fc50d93a287c4e6df" title="MPI macro: mark commands to be executed only by the master thread (myID==0).">MASTER_THREAD</a> printf(<span class="stringliteral">"                             Source direction=(%f,%f,%f), position=(%f,%f,%f)\n"</span>, source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].x,source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].y,source_data-&gt;<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[i].z, source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[i].x,source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[i].y,source_data-&gt;<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[i].z);  <span class="comment">// !!DeBuG!! Verbose</span>
<a name="l01727"></a>01727 
<a name="l01728"></a>01728     cos_rX = cos(rotX);
<a name="l01729"></a>01729     cos_rZ = cos(rotZ);
<a name="l01730"></a>01730     sin_rX = sin(rotX);
<a name="l01731"></a>01731     sin_rZ = sin(rotZ);
<a name="l01732"></a>01732     detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][0] =  cos_rZ;    <span class="comment">// Rotation matrix RxRz:</span>
<a name="l01733"></a>01733     detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][1] = -sin_rZ;
<a name="l01734"></a>01734     detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][2] =  0.0f;
<a name="l01735"></a>01735     detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][3] =  cos_rX*sin_rZ;
<a name="l01736"></a>01736     detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][4] =  cos_rX*cos_rZ;
<a name="l01737"></a>01737     detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][5] = -sin_rX;
<a name="l01738"></a>01738     detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][6] =  sin_rX*sin_rZ;
<a name="l01739"></a>01739     detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][7] =  sin_rX*cos_rZ;
<a name="l01740"></a>01740     detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][8] =  cos_rX;
<a name="l01741"></a>01741 
<a name="l01742"></a>01742 
<a name="l01743"></a>01743     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[i].x = detector_center.x*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][0] + detector_center.y*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][1] + detector_center.z*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][2];
<a name="l01744"></a>01744     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[i].y = detector_center.x*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][3] + detector_center.y*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][4] + detector_center.z*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][5];
<a name="l01745"></a>01745     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[i].z = detector_center.x*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][6] + detector_center.y*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][7] + detector_center.z*detector_data-&gt;<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[i][8];
<a name="l01746"></a>01746 
<a name="l01747"></a>01747     <span class="comment">// -- Set the lower corner (minimum) coordinates at the normalized orientation: +Y. The detector has thickness 0.</span>
<a name="l01748"></a>01748     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[i].x = detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[i].x - 0.5*detector_data-&gt;<a class="code" href="structdetector__struct.html#1f67c512205953e75552865ae7a2490a">width_X</a>;
<a name="l01749"></a>01749     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[i].y = detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[i].y;
<a name="l01750"></a>01750     detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[i].z = detector_data-&gt;<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[i].z - 0.5*detector_data-&gt;<a class="code" href="structdetector__struct.html#f61592c77c6da548fff31215bf956dd8">height_Z</a>;
<a name="l01751"></a>01751 
<a name="l01752"></a>01752     <span class="comment">// *** Init the fan beam source model:</span>
<a name="l01753"></a>01753 
<a name="l01754"></a>01754       rotZ = -rotZ;   <span class="comment">// The source rotation is the inverse of the detector.</span>
<a name="l01755"></a>01755       cos_rX = cos(rotX);
<a name="l01756"></a>01756       cos_rZ = cos(rotZ);
<a name="l01757"></a>01757       sin_rX = sin(rotX);
<a name="l01758"></a>01758       sin_rZ = sin(rotZ);
<a name="l01759"></a>01759       <span class="comment">// --Rotation around X (alpha) and then around Z (phi): Rz*Rx (oposite of detector rotation)</span>
<a name="l01760"></a>01760       source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[i][0] =  cos_rZ;
<a name="l01761"></a>01761       source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[i][1] = -cos_rX*sin_rZ;
<a name="l01762"></a>01762       source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[i][2] =  sin_rX*sin_rZ;
<a name="l01763"></a>01763       source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[i][3] =  sin_rZ;
<a name="l01764"></a>01764       source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[i][4] =  cos_rX*cos_rZ;
<a name="l01765"></a>01765       source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[i][5] = -sin_rX*cos_rZ;
<a name="l01766"></a>01766       source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[i][6] =  0.0f;
<a name="l01767"></a>01767       source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[i][7] =  sin_rX;
<a name="l01768"></a>01768       source_data-&gt;<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[i][8] =  cos_rX;
<a name="l01769"></a>01769 
<a name="l01770"></a>01770         <span class="comment">// printf("\n    -- Source location and direction for the following CT projection:\n");   // !!DeBuG!! Verbose</span>
<a name="l01771"></a>01771         <span class="comment">// printf("                 angle between projections = %lf degrees\n", D_angle*RAD2DEG);</span>
<a name="l01772"></a>01772         <span class="comment">// printf("                             current angle = %lf degrees\n", current_angle*RAD2DEG);</span>
<a name="l01773"></a>01773         <span class="comment">// printf("                   new focal spot position = (%f, %f, %f)\n", source_data-&gt;position[i].x, source_data-&gt;position[i].y, source_data-&gt;position[i].z);</span>
<a name="l01774"></a>01774         <span class="comment">// printf("                      new source direction = (%f, %f, %f)\n", source_data-&gt;direction[i].x, source_data-&gt;direction[i].y, source_data-&gt;direction[i].z);</span>
<a name="l01775"></a>01775         <span class="comment">// printf("                       new detector center = (%f, %f, %f)\n", detector_center.x, detector_center.y, detector_center.z);</span>
<a name="l01776"></a>01776         <span class="comment">// printf("           new detector low corner (at +Y) = (%f, %f, %f)\n", detector_data-&gt;corner_min_rotated_to_Y[i].x, detector_data-&gt;corner_min_rotated_to_Y[i].y, detector_data-&gt;corner_min_rotated_to_Y[i].z);</span>
<a name="l01777"></a>01777         <span class="comment">// printf("                        center of rotation = (%f, %f, %f)\n", center_rotation.x, center_rotation.y, center_rotation.z);</span>
<a name="l01778"></a>01778         <span class="comment">// printf("         detector width (X) and height (Z) = %f , %f cm\n", detector_data-&gt;width_X, detector_data-&gt;height_Z);</span>
<a name="l01779"></a>01779         <span class="comment">// printf("            rotations to +Y around Z and X = %f , %f degrees\n", rotZ*RAD2DEG, rotX*RAD2DEG);</span>
<a name="l01780"></a>01780   }
<a name="l01781"></a>01781 }<span class="comment"></span>
<a name="l01782"></a>01782 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
<a name="l01783"></a>01783 <span class="comment"></span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jun 3 13:10:12 2010 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
